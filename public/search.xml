<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2024/07/19/hexo-usage/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a class="link"   href="https://hexo.io/" >Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! This is your very first post. Check <a class="link"   href="https://hexo.io/docs/" >documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link"   href="https://hexo.io/docs/troubleshooting.html" >troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or you can ask me on <a class="link"   href="https://github.com/hexojs/hexo/issues" >GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/writing.html" >Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/server.html" >Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/generating.html" >Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure></div>

<p>More info: <a class="link"   href="https://hexo.io/docs/one-command-deployment.html" >Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>hexo实践</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>hello world</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo创建categories页面</title>
    <url>/2024/08/06/hexo-usage/hexo%E5%88%9B%E5%BB%BAcategories%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<p>hexo如何生成“分类”页并添加tpye属性？</p>
<span id="more"></span>

<h1 id="创建“分类”选项"><a href="#创建“分类”选项" class="headerlink" title="创建“分类”选项"></a>创建“分类”选项</h1><h2 id="1-生成“分类”页并添加tpye属性"><a href="#1-生成“分类”页并添加tpye属性" class="headerlink" title="1 生成“分类”页并添加tpye属性"></a>1 生成“分类”页并添加tpye属性</h2><p>打开命令行，进入博客所在文件夹。执行命令</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure></div>

<p>成功后会提示：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">INFO  Created: ~/Documents/blog/source/categories/index.md</span><br></pre></td></tr></table></figure></div>

<p>根据上面的路径，找到index.md这个文件，打开后默认内容是这样的：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2017-05-27 13:47:40</span><br><span class="line">---</span><br></pre></td></tr></table></figure></div>
<p>添加type: “categories”到内容中，添加后是这样的：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2017-05-27 13:47:40</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></div>
<p>保存并关闭文件。</p>
<h2 id="2-给文章添加“categories”属性"><a href="#2-给文章添加“categories”属性" class="headerlink" title="2 给文章添加“categories”属性"></a>2 给文章添加“categories”属性</h2><p>打开需要添加分类的文章，为其添加categories属性。下方的categories: web前端表示添加这篇文章到“web前端”这个分类。注意：hexo一篇文章只能属于一个分类，也就是说如果在“- web前端”下方添加“-xxx”，hexo不会产生两个分类，而是把分类嵌套（即该文章属于 “- web前端”下的 “-xxx ”分类）。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: jQuery对表单的操作及更多应用</span><br><span class="line">date: 2017-05-26 12:12:57</span><br><span class="line">categories: </span><br><span class="line">- web前端</span><br><span class="line">---</span><br></pre></td></tr></table></figure></div>

<p>至此，成功给文章添加分类，点击首页的“分类”可以看到该分类下的所有文章。当然，只有添加了categories: xxx的文章才会被收录到首页的“分类”中。</p>
]]></content>
      <categories>
        <category>hexo实践</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo创建tags页面</title>
    <url>/2024/08/06/hexo-usage/hexo%E5%88%9B%E5%BB%BAtags%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<p>hexo如何生成“标签”页并添加tpye属性？</p>
<span id="more"></span>

<h1 id="创建“标签”选项"><a href="#创建“标签”选项" class="headerlink" title="创建“标签”选项"></a>创建“标签”选项</h1><h2 id="1-生成“标签”页并添加tpye属性"><a href="#1-生成“标签”页并添加tpye属性" class="headerlink" title="1 生成“标签”页并添加tpye属性"></a>1 生成“标签”页并添加tpye属性</h2><p>打开命令行，进入博客所在文件夹。执行命令</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure></div>

<p>成功后会提示：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">INFO  Created: ~/Documents/blog/source/tags/index.md</span><br></pre></td></tr></table></figure></div>

<p>根据上面的路径，找到index.md这个文件，打开后默认内容是这样的：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2017-05-27 14:22:08</span><br><span class="line">---</span><br></pre></td></tr></table></figure></div>

<p>添加type: “tags”到内容中，添加后是这样的：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2017-05-27 13:47:40</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></div>

<p>保存并关闭文件。</p>
<h2 id="2-给文章添加“tags”属性"><a href="#2-给文章添加“tags”属性" class="headerlink" title="2 给文章添加“tags”属性"></a>2 给文章添加“tags”属性</h2><p>打开需要添加标签的文章，为其添加tags属性。下方的tags:下方的- jQuery - 表格</p>
<ul>
<li>表单验证就是这篇文章的标签了</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: jQuery对表单的操作及更多应用</span><br><span class="line">date: 2017-05-26 12:12:57</span><br><span class="line">categories: </span><br><span class="line">- web前端</span><br><span class="line">tags:</span><br><span class="line">- jQuery</span><br><span class="line">- 表格</span><br><span class="line">- 表单验证</span><br><span class="line">---</span><br></pre></td></tr></table></figure></div>

<p>至此，成功给文章添加分类，点击首页的“标签”可以看到该标签下的所有文章。当然，只有添加了tags: xxx的文章才会被收录到首页的“标签”中。</p>
]]></content>
      <categories>
        <category>hexo实践</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo new page xxx</title>
    <url>/2024/08/06/hexo-usage/hexo%E6%96%B0%E5%BB%BA%E9%A1%B5%E9%9D%A2/</url>
    <content><![CDATA[<p>使用 Hexo 生成一个新页面，可以通过命令行输入以下命令：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">hexo new page &lt;page_name&gt;</span><br></pre></td></tr></table></figure></div>

<p>其中，<code>&lt;page_name&gt;</code> 是你希望新页面的名称。例如，如果你想创建一个名为 “about” 的页面，你可以输入：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure></div>

<p>这将会在 <code>source</code> 目录下创建一个名为 <code>about</code> 的文件夹，其中包含一个 <code>index.md</code> 文件，你可以在这个文件中编写页面的内容。</p>
<h3 id="完整步骤"><a href="#完整步骤" class="headerlink" title="完整步骤"></a>完整步骤</h3><ol>
<li><p><strong>确保你在 Hexo 博客的根目录下</strong>：你需要在 Hexo 项目的根目录下运行命令。你可以使用 <code>cd</code> 命令导航到你的 Hexo 项目根目录。例如：</p>
 <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/your/hexo/project</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>生成新页面</strong>：运行以下命令生成新页面。</p>
 <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">hexo new page &lt;page_name&gt;</span><br></pre></td></tr></table></figure></div>

<p> 例如：</p>
 <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>编辑新页面</strong>：生成的新页面会在 <code>source</code> 目录下创建一个以页面名称命名的文件夹，并包含一个 <code>index.md</code> 文件。你可以编辑这个文件来添加页面内容。</p>
 <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">vi <span class="built_in">source</span>/about/index.md</span><br></pre></td></tr></table></figure></div>

<p> 在这个文件中，你可以编写 Markdown 格式的内容。默认情况下，文件内容如下：</p>
 <div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: about</span><br><span class="line"><span class="section">date: 2024-07-30 12:00:00</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></div>

<p> 你可以在 <code>---</code> 下面添加页面的实际内容。</p>
</li>
<li><p><strong>生成和部署</strong>：完成编辑后，你可以生成静态文件并将其部署到你的服务器或托管平台。</p>
 <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure></div>

<p> 或者可以简化为：</p>
 <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设你想创建一个 “contact” 页面，步骤如下：</p>
<ol>
<li><p><strong>导航到 Hexo 项目根目录</strong>：</p>
 <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /path/to/your/hexo/project</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>生成 “contact” 页面</strong>：</p>
 <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">hexo new page contact</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>编辑 <code>source/contact/index.md</code></strong> 文件：</p>
 <div class="highlight-container" data-rel="Markdown"><figure class="iseeu highlight markdown"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: contact</span><br><span class="line"><span class="section">date: 2024-07-30 12:00:00</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line"><span class="section"># Contact Us</span></span><br><span class="line"></span><br><span class="line">Feel free to reach out via email at example@example.com.</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>生成并部署</strong>：</p>
 <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure></div></li>
</ol>
<p>这样，你的 Hexo 博客将会有一个新的 “contact” 页面，你可以通过 <code>http://your-blog-url/contact</code> 来访问它。</p>
]]></content>
      <categories>
        <category>hexo实践</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>new page</tag>
      </tags>
  </entry>
  <entry>
    <title>git module 如何拉取仓库</title>
    <url>/2024/08/06/git%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/001-%E6%8B%89%E5%8F%96submoduls%E4%BB%93%E5%BA%93/README/</url>
    <content><![CDATA[<p>在Git中，子模块（submodule）是一种将一个Git仓库作为另一个Git仓库的子目录的方式。使用子模块可以在一个项目中包含其他项目，并且保持它们各自的版本控制和独立性。</p>
<span id="more"></span>

<h3 id="如何拉取包含子模块的仓库"><a href="#如何拉取包含子模块的仓库" class="headerlink" title="如何拉取包含子模块的仓库"></a>如何拉取包含子模块的仓库</h3><p>以下是完整的步骤，从克隆一个包含子模块的仓库到拉取子模块的详细过程：</p>
<h4 id="1-克隆包含子模块的仓库"><a href="#1-克隆包含子模块的仓库" class="headerlink" title="1. 克隆包含子模块的仓库"></a>1. 克隆包含子模块的仓库</h4><p>当你克隆一个包含子模块的仓库时，你需要使用<code>--recurse-submodules</code>选项，这样会在克隆主仓库的同时，初始化并更新所有子模块。</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recurse-submodules &lt;repository_url&gt;</span><br></pre></td></tr></table></figure></div>

<p>例如：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recurse-submodules https://github.com/user/repo.git</span><br></pre></td></tr></table></figure></div>

<h4 id="2-初始化和更新子模块（如果已经克隆了仓库）"><a href="#2-初始化和更新子模块（如果已经克隆了仓库）" class="headerlink" title="2. 初始化和更新子模块（如果已经克隆了仓库）"></a>2. 初始化和更新子模块（如果已经克隆了仓库）</h4><p>如果你已经克隆了仓库，但没有使用<code>--recurse-submodules</code>选项，可以使用以下命令来初始化和更新子模块：</p>
<div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> &lt;repository_directory&gt;</span><br><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure></div>

<h4 id="3-拉取更新（更新已有仓库中的子模块）"><a href="#3-拉取更新（更新已有仓库中的子模块）" class="headerlink" title="3. 拉取更新（更新已有仓库中的子模块）"></a>3. 拉取更新（更新已有仓库中的子模块）</h4><p>如果你已经有一个包含子模块的仓库，并且想要拉取主仓库和子模块的最新更改，可以按以下步骤操作：</p>
<ol>
<li><p><strong>拉取主仓库的更新：</strong></p>
 <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>更新子模块：</strong></p>
 <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">git submodule update --recursive --remote</span><br></pre></td></tr></table></figure></div>

<p> <code>--remote</code>选项会从子模块的远程仓库拉取最新提交。通常情况下，<code>git submodule update --recursive</code>就足够了，它会将子模块更新到主仓库记录的特定提交。</p>
</li>
</ol>
<h4 id="4-将子模块添加到仓库"><a href="#4-将子模块添加到仓库" class="headerlink" title="4. 将子模块添加到仓库"></a>4. 将子模块添加到仓库</h4><p>如果你想要将一个子模块添加到你的仓库中，可以使用以下步骤：</p>
<ol>
<li><p><strong>添加子模块：</strong></p>
 <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">git submodule add &lt;repository_url&gt; &lt;path&gt;</span><br></pre></td></tr></table></figure></div>

<p> 例如：</p>
 <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">git submodule add https://github.com/user/submodule-repo.git path/to/submodule</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>提交子模块更改：</strong></p>
 <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;Add submodule&quot;</span></span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>推送更改：</strong></p>
 <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">git push</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h4 id="示例操作"><a href="#示例操作" class="headerlink" title="示例操作"></a>示例操作</h4><p>以下是一个完整的操作示例，从添加子模块到更新子模块：</p>
<ol>
<li><p><strong>添加子模块：</strong></p>
 <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">git submodule add https://github.com/example/repo.git libs/repo</span><br><span class="line">git commit -m <span class="string">&quot;Add submodule repo&quot;</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>克隆包含子模块的仓库：</strong></p>
 <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --recurse-submodules https://github.com/your/repo.git</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>初始化和更新子模块（如果已经克隆了仓库）：</strong></p>
 <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">git submodule update --init --recursive</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>拉取更新并更新子模块：</strong></p>
 <div class="highlight-container" data-rel="Sh"><figure class="iseeu highlight sh"><table><tr><td class="code"><pre><span class="line">git pull</span><br><span class="line">git submodule update --recursive --remote</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>通过使用Git子模块，你可以轻松地将其他项目包含到你的项目中，并且保持它们独立的版本控制。理解并掌握子模块的初始化、更新和管理方法，可以帮助你在处理大型项目或依赖多个项目时更加高效。</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>submodule</tag>
      </tags>
  </entry>
  <entry>
    <title>.gitignore设置</title>
    <url>/2024/08/06/git%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C/002-gitignore/README/</url>
    <content><![CDATA[<ul>
<li><a class="link"   href="https://orianna-zzo.github.io/sci-tech/2018-01/mac%E4%B8%ADgit%E5%BF%BD%E7%95%A5.ds_store%E6%96%87%E4%BB%B6/" >原文 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<span id="more"></span>

<h2 id="Git中多出来的-DS-Store"><a href="#Git中多出来的-DS-Store" class="headerlink" title="Git中多出来的.DS_Store"></a>Git中多出来的.DS_Store</h2><p>虽然不是第一次使用mac，也不是第一次在mac上使用git，但对mac实际上非常不熟悉。每次git上传时多出来的.DS_Store文件虽然不清楚具体做什么，但看上去并没什么问题。git一般也是自己一个人单机使用，就算换机也一般是直接换，没有遇到过两个同时使用的时候，上传.DS_Store也就默认都上传了。</p>
<p>但这次用两个mac，一个mac提交了修改，第二个mac想要拉下来时居然遇到了.DS_Store文件被修改过需要提交再merge。什么？我没改过内容呀？所以这个.DS_Store是什么鬼？</p>
<p>.DS_Store是Mac OS用来存储这个文件夹的显示属性的，被作为一种通用的有关显示设置的元数据（比如图标位置等设置）为Finder、Spotlight用。所以在不经意间就会修改这个文件。而文件共享时为了隐私关系将.DS_Store文件删除比较好，因为其中有一些信息在不经意间泄露出去。</p>
<h2 id="Git中处理方案"><a href="#Git中处理方案" class="headerlink" title="Git中处理方案"></a>Git中处理方案</h2><h3 id="方案一：项目设置-gitignore"><a href="#方案一：项目设置-gitignore" class="headerlink" title="方案一：项目设置.gitignore"></a>方案一：项目设置.gitignore</h3><p>仅针对git的处理最naive的想法就是设置.gitignore文件。</p>
<p>.gitignore文件用于忽略文件，官网介绍在这里，规范如下：</p>
<ul>
<li>所有空行或者以注释符号 ＃ 开头的行都会被 git 忽略，空行可以为了可读性分隔段落，# 表明注释。</li>
<li>第一个 &#x2F; 会匹配路径的根目录，举个栗子，”&#x2F;*.html”会匹配”index.html”，而不是”d&#x2F;index.html”。</li>
<li>通配符 * 匹配任意个任意字符，? 匹配一个任意字符。需要注意的是通配符不会匹配文件路径中的 &#x2F;，举个栗子，”d&#x2F;*.html”会匹配”d&#x2F;index.html”，但不会匹配”d&#x2F;a&#x2F;b&#x2F;c&#x2F;index.html”。</li>
<li>两个连续的星号 ** 有特殊含义：<ul>
<li>以 **&#x2F; 开头表示匹配所有的文件夹，例如 **&#x2F;test.md 匹配所有的test.md文件。</li>
<li>以 &#x2F;** 结尾表示匹配文件夹内所有内容，例如 a&#x2F;** 匹配文件夹a中所有内容。</li>
<li>连续星号 ** 前后分别被 &#x2F; 夹住表示匹配0或者多层文件夹，例如 a&#x2F;**&#x2F;b 匹配到 a&#x2F;b 、a&#x2F;x&#x2F;b 、a&#x2F;x&#x2F;y&#x2F;b 等。</li>
</ul>
</li>
<li>前缀 ! 的模式表示如果前面匹配到被忽略，则重新添加回来。如果匹配到的父文件夹还是忽略状态，该文件还是保持忽略状态。如果路径名第一个字符为 ! ，则需要在前面增加 \ 进行转义。</li>
</ul>
<p>对于一些常用的系统、工程文件的.gitignore文件可以参考这个网站进行设置，这里有很多模板。</p>
<p>针对.DS_Store文件，在git工程文件夹中新建.gitignore文件，在文件中设置：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">.gitignore</span><br><span class="line">**/.DS_Store</span><br></pre></td></tr></table></figure></div>

<p>对于已经提交的内容，希望git能够忽略，但同时并不会删除本地文件，需要在terminal输入以下命令：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git rm -r --cached $file_path</span><br></pre></td></tr></table></figure></div>
<p>这个方案的优点就是方便、快捷、最容易想到，缺点就是每个git项目都要重复一遍。</p>
<h3 id="方案二：全局设置忽略"><a href="#方案二：全局设置忽略" class="headerlink" title="方案二：全局设置忽略"></a>方案二：全局设置忽略</h3><p>虽然每个项目配.gitignore文件可以成功，但是每个项目都需要配，嗯，有点烦。我们可以在git的全局进行配置来忽略.DS_Store文件。</p>
<p>设置之前我们先看下现在的git config配置情况（git config官方文档说明）：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --list</span><br></pre></td></tr></table></figure></div>
<p>实际上git配置情况可以在 ~&#x2F;.gitconfig 文件中查看。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ vi ~/.gitconfig</span><br></pre></td></tr></table></figure></div>
<p>通过 <code>:q!</code> 退出后，我们需要建立一个文件，把需要全局忽略的文件路径写入其中。该文件起名为.gitignore_global：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ touch ~/.gitignore_global</span><br></pre></td></tr></table></figure></div>
<p>然后对这个文件进行修改。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Mac OS</span><br><span class="line">**/.DS_Store</span><br></pre></td></tr></table></figure></div>
<p>然后对git进行全局设置，让git忽略.gitignore_global中的所有文件：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git config --global core.excludesfile ~/.gitignore_global</span><br></pre></td></tr></table></figure></div>
<p>这样就不用每个git目录都设置忽略.DS_Store文件了！</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>.gitignore</tag>
        <tag>.gitignore_global</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo使用记录 - 2024</title>
    <url>/2024/07/19/hexo-usage/hexo-usage-2024/hexo2024/</url>
    <content><![CDATA[<h1 id="一、2018的记录"><a href="#一、2018的记录" class="headerlink" title="一、2018的记录"></a>一、2018的记录</h1><p><a class="link"   href="https://www.jianshu.com/p/0206f62000a1" >Mac+Hexo+github搭建myblog完整版 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h1 id="二、2024新记录"><a href="#二、2024新记录" class="headerlink" title="二、2024新记录"></a>二、2024新记录</h1><h2 id="1-图片相关设置"><a href="#1-图片相关设置" class="headerlink" title="1. 图片相关设置"></a>1. 图片相关设置</h2><h3 id="a-图床设置"><a href="#a-图床设置" class="headerlink" title="a. 图床设置"></a>a. 图床设置</h3><blockquote>
<p>使用 <code>Picgo</code> + <code>Github</code></p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/lionsom/imagesRepo/hexo/001-hexo-usage/202407221550864.png"
                     
                ></p>
<h3 id="b-图片引入方式"><a href="#b-图片引入方式" class="headerlink" title="b. 图片引入方式"></a>b. 图片引入方式</h3><p><a href="https://linxiang.netlify.app/categories/hexo%E5%AE%9E%E8%B7%B5/">单独的文章详细说明了图片引入方式</a></p>
<h4 id="Ⅰ-全局资源（共用资源）"><a href="#Ⅰ-全局资源（共用资源）" class="headerlink" title="Ⅰ. 全局资源（共用资源）"></a>Ⅰ. 全局资源（共用资源）</h4><p>例如：全局头像、背景图片等。</p>
<ol>
<li>在<code>source</code>目录下创建<code>source/global-assets</code>文件夹，与<code>_posts</code>同级，将图片放入其中。</li>
<li>直接引用 <code>![](global-assets/myhead.jpg)</code></li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/global-assets/myhead.jpg"
                     
                ></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/global-assets/myhead.jpg"
                      width="40%" 
                >

<h4 id="Ⅱ-文章资源"><a href="#Ⅱ-文章资源" class="headerlink" title="Ⅱ. 文章资源"></a>Ⅱ. 文章资源</h4><p>指的是每个文档的图片资源，便于管理。</p>
<ol>
<li>在当个文档中创建同名文件夹，例如<code>015-hexo-usage/hexo2024</code>，在同路径下 <code>015-hexo-usage/hexo2024.md</code>中引用。</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/19/hexo-usage/hexo-usage-2024/hexo2024/myhead.jpg"
                      alt="文章资源"
                ></p>
<img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="myhead.jpg"
                      width="50%" 
                >


<h3 id="c-图片排版"><a href="#c-图片排版" class="headerlink" title="c. 图片排版"></a>c. 图片排版</h3><p align = "center">
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/348f8ce8a69c97427cf55dde66f1b4c7.png"
                      width="20%" 
                >
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/348f8ce8a69c97427cf55dde66f1b4c7.png"
                      width="30%" 
                >
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/348f8ce8a69c97427cf55dde66f1b4c7.png"
                      width="400" 
                >
  <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://i-blog.csdnimg.cn/blog_migrate/348f8ce8a69c97427cf55dde66f1b4c7.png"
                      width="100" 
                >
</p>


<h2 id="2-本地预览"><a href="#2-本地预览" class="headerlink" title="2. 本地预览"></a>2. 本地预览</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure></div>

<h2 id="3-Netlify部署"><a href="#3-Netlify部署" class="headerlink" title="3. Netlify部署"></a>3. Netlify部署</h2><p><a class="link"   href="https://app.netlify.com/" >Netlify官网 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<ol>
<li>先本地构建<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ hexo clean     # or hexo c</span><br><span class="line">$ hexo generate  # or hexo g</span><br></pre></td></tr></table></figure></div></li>
<li>再提交代码，Netlify会自动部署。</li>
</ol>
<h2 id="4-主题设置"><a href="#4-主题设置" class="headerlink" title="4. 主题设置"></a>4. 主题设置</h2><ol>
<li>前往Hexo工程目录下themes下；</li>
<li><code>$ git submodule add https://github.com/EvanNotFound/hexo-theme-redefine.git</code></li>
<li>添加submodule，否则Netlify无法部署；</li>
<li>修改<code>_config.yml</code>文件，将<code>theme: next</code>修改为<code>theme: hexo-theme-redefine</code>；</li>
<li>提交代码到github，Netlify会自动部署。</li>
</ol>
<h2 id="5-redefine主题自定义"><a href="#5-redefine主题自定义" class="headerlink" title="5. redefine主题自定义"></a>5. redefine主题自定义</h2><p><a class="link"   href="https://github.com/EvanNotFound/hexo-theme-redefine" >redefine <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://redefine-docs.ohevan.com/getting-started" >redefine-docs <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="6-生成aa"><a href="#6-生成aa" class="headerlink" title="6. 生成aa"></a>6. 生成aa</h2>]]></content>
      <categories>
        <category>hexo实践</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
        <tag>picgo</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo本地图片</title>
    <url>/2024/08/09/hexo-usage/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/</url>
    <content><![CDATA[<h1 id="Hexo-官方插入本地图片方法"><a href="#Hexo-官方插入本地图片方法" class="headerlink" title="Hexo 官方插入本地图片方法"></a>Hexo 官方插入本地图片方法</h1><ul>
<li><a class="link"   href="https://hexo.io/zh-cn/docs/asset-folders" >hexo官网 - 资源文件夹 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<h2 id="1-绝对路径（全局图片）"><a href="#1-绝对路径（全局图片）" class="headerlink" title="1. 绝对路径（全局图片）"></a>1. 绝对路径（全局图片）</h2><p>如果你的Hexo项目中只有少量图片，那最简单的方法就是将它们统一放在 <code>source/images</code> 文件夹中。然后通过以下方法进行访问。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">![](/imges/image.jpg)</span><br></pre></td></tr></table></figure></div>

<p>图片既可以在首页内容中访问到，也可以在文章正文中访问到。</p>
<h2 id="2-相对路径（文章图片）"><a href="#2-相对路径（文章图片）" class="headerlink" title="2. 相对路径（文章图片）"></a>2. 相对路径（文章图片）</h2><p>图片除了可以放在统一的 <code>source/images</code> 文件夹中，还可以放在文章自己的目录中。文章的目录可以通过配置 <code>_config.yml</code> 来生成。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">post_asset_folder: true</span><br></pre></td></tr></table></figure></div>

<p>将 <code>_config.yml</code> 文件中的配置项 <code>post_asset_folder</code> 设为 <code>true</code> 后，执行命令 <code>hexo new post_name</code>，在 <code>source/_posts</code> 中会生成文章 <code>post_name.md</code> 和同名文件夹 <code>post_name</code>。将图片资源放在 <code>post_name</code> 中，文章就可以使用相对路径引用图片资源了。引用图片的方法如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">![](image.jpg)</span><br></pre></td></tr></table></figure></div>

<p>以上这种引用方法，图片只能在文章中显示，但无法在首页中正常显示。如果希望图片在文章和首页中同时显示，可以使用标签插件语法。</p>
<h1 id="3-标签插件"><a href="#3-标签插件" class="headerlink" title="3. 标签插件"></a>3. 标签插件</h1><p>通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。</p>
<p>引用语法如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% asset_path slug %&#125;</span><br><span class="line">&#123;% asset_img slug [title] %&#125;</span><br><span class="line">&#123;% asset_link slug [title] %&#125;</span><br></pre></td></tr></table></figure></div>

<p>在上述语法下，引用图片的方法如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;%  asset_img example.jpg This is an example image %&#125;</span><br></pre></td></tr></table></figure></div>

<p>通过这种方式，图片将会同时出现在文章和主页以及归档页中。</p>
<h1 id="二、图床"><a href="#二、图床" class="headerlink" title="二、图床"></a>二、图床</h1><h3 id="a-图床设置"><a href="#a-图床设置" class="headerlink" title="a. 图床设置"></a>a. 图床设置</h3><blockquote>
<p>使用 <code>Picgo</code> + <code>Github</code></p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="https://raw.githubusercontent.com/lionsom/imagesRepo/hexo/001-hexo-usage/202407221550864.png"
                     
                ></p>
<h1 id="三、插件"><a href="#三、插件" class="headerlink" title="三、插件"></a>三、插件</h1><p>六种图片引入方式：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 文件夹名称不一样</span><br><span class="line">![1](A.gif)</span><br><span class="line">![2](assets/A.gif)</span><br><span class="line">![3](./assets/A.gif)</span><br><span class="line"></span><br><span class="line"># 文件夹名称一样</span><br><span class="line">![4](myhead.jpg)</span><br><span class="line">![5](hexo本地图片/myhead.jpg)</span><br><span class="line">![6](./hexo本地图片/myhead.jpg)</span><br></pre></td></tr></table></figure></div>

<ul>
<li>未安装 <code>hexo-asset-image</code> 插件，图片无法显示。<ul>
<li>本地：1 4 不显示，2 3 5 6 显示</li>
<li>远程：4 显示，其他不显示</li>
</ul>
</li>
<li>安装 <code>hexo-asset-image</code></li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/A.gif"
                      alt="1"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/assets/A.gif"
                      alt="2"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./assets/A.gif"
                      alt="3"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/08/09/hexo-usage/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/myhead.jpg"
                      alt="4"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/myhead.jpg"
                      alt="5"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/./hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87/myhead.jpg"
                      alt="6"
                ></p>
]]></content>
      <categories>
        <category>hexo实践</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>let、const解决了什么问题？</title>
    <url>/2024/08/09/%E5%89%8D%E7%AB%AF/ES6/001-let%E3%80%81const%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F/index/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>今天来聊一聊腾讯的一个面试题，let、const解决了什么问题？</p>
<h2 id="let、const解决了什么问题？"><a href="#let、const解决了什么问题？" class="headerlink" title="let、const解决了什么问题？"></a>let、const解决了什么问题？</h2><p>我们来分析一下这个问题</p>
<p>首先这个问题问我们let、const解决了什么问题？</p>
<p>我们就需要去分别讲解一个let和const是干什么用的</p>
<p>首先let和const是es6后面才有的东西，既然问到这个说明面试官的问题聚焦到了es6的范围</p>
<p>既然如此我们就一定知道我们首先需要讲一下let和const是干什么的</p>
<p>还要说明es6的let和const对比之前的var的优势在哪里</p>
<h2 id="let关键字"><a href="#let关键字" class="headerlink" title="let关键字"></a>let关键字</h2><p>let是JavaScript中用于声明变量的关键字,它于2015年被ES6(ECMAScript 6)标准引入。与较早的var关键字相比,let有以下几个主要特点:</p>
<ol>
<li>块级作用域(Block Scope)</li>
</ol>
<p>使用let声明的变量具有块级作用域,即它们只在声明该变量的花括号{}内部可见和访问。这与使用var声明的变量具有函数作用域(Function Scope)的行为不同。</p>
<ol start="2">
<li>暂时性死区(Temporal Dead Zone, TDZ)</li>
</ol>
<p>在变量声明之前使用let声明的变量会进入暂时性死区,此时访问该变量会抛出ReferenceError。这与使用var声明的变量在未初始化前默认值为undefined的行为不同。</p>
<ol start="3">
<li>无变量提升(No Hoisting)</li>
</ol>
<p>let声明的变量不会像var一样被提升到作用域顶部,这意味着在声明之前无法访问let声明的变量。</p>
<ol start="4">
<li>不允许重复声明</li>
</ol>
<p>在同一作用域内,使用let声明的变量不允许被重复声明,否则会抛出SyntaxError。而var则可以在同一作用域内重复声明同名变量而不会报错。</p>
<p>let关键字提供了更加严格和直观的变量声明和作用域行为,有利于编写更加健壮和可维护的JavaScript代码。它的块级作用域、暂时性死区和无变量提升等特性,都有助于帮助开发者更好地管理变量的生命周期和作用域。</p>
<h2 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h2><p>let关键字有的它都有，唯一的区别就是它被赋初值以后无法修改</p>
<h2 id="let和const对比var，优势在哪里"><a href="#let和const对比var，优势在哪里" class="headerlink" title="let和const对比var，优势在哪里"></a>let和const对比var，优势在哪里</h2><p>ES6的使命是让JavaScript能够成为Java一样的企业级大型语言</p>
<ol>
<li>作用域管理更加清晰和直观</li>
</ol>
<ul>
<li>var声明的变量具有函数作用域或全局作用域,这可能会导致意料之外的变量污染和泄露。</li>
<li>let和const声明的变量具有块级作用域,限定在它们所在的花括号{}内部,使得变量的作用域更加明确和可控。</li>
</ul>
<ol start="2">
<li>避免变量提升问题</li>
</ol>
<ul>
<li>var声明的变量会被提升到作用域顶部,这可能会导致意料之外的行为。</li>
<li>let和const声明的变量不会被提升,必须在声明之后才能访问,避免了这种问题。</li>
</ul>
<ol start="3">
<li>引入暂时性死区(TDZ)</li>
</ol>
<ul>
<li>let和const声明的变量在声明之前会进入暂时性死区,访问会抛出ReferenceError。这有助于避免一些隐藏的bug。</li>
<li>var声明的变量在未初始化前默认值为undefined,可能会导致一些隐藏的错误。</li>
</ul>
<ol start="4">
<li>支持常量声明</li>
</ol>
<ul>
<li>const关键字允许声明不可变的常量变量,有助于增强代码的可读性和稳定性。</li>
<li>var无法直接声明常量,需要使用一些其他手段来实现。</li>
</ul>
<ol start="5">
<li>不允许重复声明</li>
</ol>
<ul>
<li>let和const不允许在同一作用域内重复声明同名变量,有利于避免一些细微的错误。</li>
<li>var则可以在同一作用域内重复声明同名变量而不会报错。</li>
</ul>
<p>ES6中的let和const相比var提供了更加清晰和严格的变量管理机制,有助于编写更加健壮和可维护的JavaScript代码。这些改进使得JavaScript的变量声明和作用域行为更加符合开发者的预期,减少了一些常见的错误。</p>
]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>let</tag>
        <tag>const</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是HTTP? HTTP 和 HTTPS 的区别?</title>
    <url>/2024/08/08/%E5%89%8D%E7%AB%AF/HTML/002-%E4%BB%80%E4%B9%88%E6%98%AFHTTP?%20HTTP%20%E5%92%8C%20HTTPS%20%E7%9A%84%E5%8C%BA%E5%88%AB?/index/</url>
    <content><![CDATA[<p><a class="link"   href="https://vue3js.cn/interview/http/HTTP_HTTPS.html" >参考 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>http</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>说说Cookie、Session和Token的区别？</title>
    <url>/2024/08/08/%E5%89%8D%E7%AB%AF/HTML/001-%E8%AF%B4%E8%AF%B4Cookie%E3%80%81Session%E5%92%8CToken%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/index/</url>
    <content><![CDATA[<p><a class="link"   href="https://www.51cto.com/article/775430.html" >京东面试：说说Cookie、Session和Token的区别？ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="1-Cookie、Session-和-Token-有什么区别？"><a href="#1-Cookie、Session-和-Token-有什么区别？" class="headerlink" title="1.Cookie、Session 和 Token 有什么区别？"></a>1.Cookie、Session 和 Token 有什么区别？</h2><p>Cookie、Session 和 Token 通常都是用来保存用户登录信息的技术，但三者有很大的区别，简单来说 Cookie 适用于简单的状态管理，Session 适用于需要保护用户敏感信息的场景，而 Token 适用于状态无关的身份验证和授权。</p>
<p>Token 状态无关性解析：在传统的基于会话的认证方式中，服务器需要在后端保存用户的会话状态，通过 Session ID 进行会话的管理。而 Token 机制不需要在服务器上保存任何关于用户的状态信息，只需要在登录成功时，服务器端通过某种算法生成一个唯一的 Token 值，之后再将此 Token 发送给客户端存储（存储在 localStorage 或 sessionStorage 中），注意此时服务端是不存储这个 Token 值的，服务器端只进行效验而不保存此 Token，这就叫“状态无关性”。这样就可以减轻服务器存储和管理会话状态的负担，所以它比较适用于大型系统和分布式系统。</p>
<p>具体来说，Cookie、Session 和 Token 的区别主要有以下几点区别：</p>
<p>存储位置不同：Cookie 存储在客户端，即浏览器中的文本文件，通过在 HTTP 头中传递给服务器来进行通信；Session 是服务器端的存储方式，通常存储在服务器的内存或数据库中；Token 也是存储在客户端，但是通常以加密的方式存储在客户端的 localStorage 或 sessionStorage 中。<br>数据安全性不同：Cookie 存储在客户端，可能会被窃取或篡改，因此对敏感信息的存储需要进行加密处理；Session 存储在服务器端，通过一个 Session ID 在客户端和服务器之间进行关联，可以避免敏感数据直接暴露；Token 通常使用加密算法生成，有效期较短且单向不可逆，可以提供较高的安全性。<br>跨域支持不同：为了防止安全事故，因此 Cookie 是不支持跨域传输的，也就是不同域名下的 Cookie 是不能相互访问的；而 Session 机制通常是通过 Cookie 来保存 Session ID 的，因此 Session ID 默认情况下也是不支持跨域的；但 Token 可以轻松实现跨域，因为 Token 是存储在客户端的 localStorage 或者作为请求头的一部分发送到服务器的，所以不同的域名 Token 信息传输通常是不受影响的。<br>状态管理不同：Cookie 是应用程序通过在客户端存储临时数据，用于实现状态管理的一种机制；Session 是服务器端记录用户状态的方式，服务器会为每个会话分配一个唯一的 Session ID，并将其与用户状态相关联；Token 是一种用于认证和授权的一种机制，通常表示用户的身份信息和权限信息。</p>
<h2 id="2-Cookie-和-Session-有什么关系？"><a href="#2-Cookie-和-Session-有什么关系？" class="headerlink" title="2.Cookie 和 Session 有什么关系？"></a>2.Cookie 和 Session 有什么关系？</h2><p>准确来说 Cookie 的实现和 Session 是没有任何关系的，但 Session 的实现需要借助于 Cookie。</p>
<p>Session 机制的实现流程如下：</p>
<p>会话创建：通常情况下，当用户登录成功后，服务器会为该用户创建一个新的会话。在创建会话过程中，服务器会为该会话生成一个唯一的标识符，通常称为 Session ID。<br>Session ID 传递：服务器将生成的 Session ID 通过响应的方式发送给客户端，使用 SetCookie 命令，将用户的 Session ID 保存在 Cookie 中，通常是一个名为 JSESSIONID 的 Cookie。<br>Session 数据存储：在服务器端，Session 数据会被存储在一个能够关联 Session ID 的数据结构中（例如内存、数据库或者文件存储等）。常用的方式是将 Session ID 作为键，与对应的 Session 用户身份数据进行关联。<br>Session ID 验证与检索：当用户发送一个新的请求时，客户端会将之前存储的 Session ID 携带在请求的 Cookie 或请求头中发送给服务器。服务器会根据 Session ID 找到对应的 Session 数据，从而获得用户的状态信息。<br>Session 数据使用：服务器在获取到 Session 数据后，可以根据具体需求读取、修改或删除其中保存的状态信息。服务器可以通过 Session 来管理用户的登录状态、购物车内容、用户配置等。<br>Session 过期与销毁：Session 有一个有效期限，一般通过设置一个固定的时间，或者在一定时间内没有用户活动时会将 Session 标记为过期。当 Session 过期时，服务器会销毁对应的 Session 数据，释放内存或其他资源。<br>所以默认情况下，Session 是借助 Cookie 来完成身份标识的传递的，这样服务器端才能根据 Session ID 和保存的会话信息进行关联，用于找到某个具体登录的用户，所以说：默认情况下，Session 机制是依赖 Cookie 实现的。</p>
<h2 id="3-禁用-Cookie-之后-Session-还能用吗？"><a href="#3-禁用-Cookie-之后-Session-还能用吗？" class="headerlink" title="3.禁用 Cookie 之后 Session 还能用吗？"></a>3.禁用 Cookie 之后 Session 还能用吗？</h2><p>通过上文我们知道，默认情况下 Session 机制是依赖 Cookie 实现的，那么是不是禁用了 Cookie 之后，Session 机制也就无法使用了呢？其实不然。</p>
<p>除了默认情况下，我们可以使用 Cookie 来传递 Session ID 之外，我们可以通过一些特殊的手段来自行传递 Session ID，以此来摆脱禁用 Cookie 之后 Session 无法使用的情况，例如以下两种实现手段：</p>
<p>URL Rewriting：可以在每个请求的 URL 中附加 Session ID 参数。服务器在接收到请求时，解析 URL 中的 Session ID，并与对应的 Session 数据进行关联。这种方式适用于没有禁用地址栏中的参数传递的情况。<br>隐藏表单字段：可以将 Session ID 作为隐藏表单字段的方式传递给服务器。当用户提交表单时，Session ID 将随着表单数据一起发送给服务器，服务器据此建立与当前会话的关联。<br>通过以上手段都可以将 Session ID 传递到服务器端（虽然麻烦点），然后在服务器端，我们再对以上传递的 Session ID 进行获取和映射，这样就手动完成了传递和匹配登录用户的工作了，Session 机制也得已继续使用了。</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Cookie、Session 和 Token 通常都是用来保存用户登录信息的技术，但三者的区别很大：Cookie 适用于简单的状态管理，Session 适用于需要保护用户敏感信息的场景，而 Token 适用于状态无关的身份验证和授权。默认情况下 Session 使用了 Cookie 机制来传递 Session ID，但在禁用 Cookie 的情况下，使用特殊的手段依然可以传递 Session ID，依然可以继续使用 Session 机制。而 Token 是不在服务器端保存会话信息的，因此更适用于大型项目和分布式项目。</p>
]]></content>
      <categories>
        <category>HTML</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>cookie</tag>
        <tag>session</tag>
        <tag>token</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue中v-show和v-if有什么区别？使用场景分别是什么？</title>
    <url>/2024/08/08/%E5%89%8D%E7%AB%AF/Vue/001-v-show%E5%92%8Cv-if%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/index/</url>
    <content><![CDATA[<p><a class="link"   href="https://vue3js.cn/interview/vue/show_if.html#%E4%B8%80%E3%80%81v-show%E4%B8%8Ev-if%E7%9A%84%E5%85%B1%E5%90%8C%E7%82%B9" >参考 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
        <tag>v-show</tag>
        <tag>v-if</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue组件之间的通信方式都有哪些？</title>
    <url>/2024/08/08/%E5%89%8D%E7%AB%AF/Vue/002-Vue%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F/index/</url>
    <content><![CDATA[<p><a class="link"   href="https://vue3js.cn/interview/vue/communication.html" >参考 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift面试题导航链接</title>
    <url>/2024/08/07/iOS/Swift/001-%E7%9B%AE%E5%BD%95/README/</url>
    <content><![CDATA[<p>啊啊啊啊啊啊啊</p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift与OC的区别</title>
    <url>/2024/08/07/iOS/Swift/002-Swift%E4%B8%8EOC%E7%9A%84%E5%8C%BA%E5%88%AB/README/</url>
    <content><![CDATA[<p>吃吃吃吃吃吃</p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题导航链接</title>
    <url>/2024/07/30/iOS/OC/000-%E9%9D%A2%E8%AF%95%E9%A2%98%E5%AF%BC%E8%88%AA%E9%93%BE%E6%8E%A5/README/</url>
    <content><![CDATA[<p>① <a class="link"   href="https://github.com/iOS-Mayday/heji" >BAT等各个大厂iOS面试真题+答案大全 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>② <a class="link"   href="https://github.com/iOS-Mayday/iOSAdvanced-Roadmap" >iOS中高级开发必看的热门书籍（经典必看） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<span id="more"></span>

<p>③　<a class="link"   href="https://github.com/iOS-Mayday/Interview-questions-iOS" >iOS开发高级面试”简历制作”指导 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>④　<a class="link"   href="https://github.com/iOS-Mayday/iOS-Interview-Strategy" >iOS面试流程到基础知识大全 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>⑤ <a class="link"   href="https://halfrost.com/ios_interview/" >2016年3月 iOS 面试总结 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://www.jianshu.com/p/583d7b006815" >2022年，iOS开发面试问题汇总（底层基础） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>移动端iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>APNS推送</title>
    <url>/2024/08/06/iOS/OC/021-APNS/README/</url>
    <content><![CDATA[<p>苹果推送通知服务 (Apple Push Notification Service，APNS) 是苹果公司提供的推送通知平台，用于将通知从第三方应用服务器发送到 iOS 设备。APNS 是 iOS 应用开发中非常重要的一部分，因为它允许应用在不运行的情况下仍能接收信息和更新。</p>
<span id="more"></span>

<h2 id="一、之前的总结"><a href="#一、之前的总结" class="headerlink" title="一、之前的总结"></a>一、之前的总结</h2><p><a class="link"   href="https://www.jianshu.com/p/a1c68ca79dbf" >我的简书-iOS的推送服务APNs详解 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="二、推送通知的类型"><a href="#二、推送通知的类型" class="headerlink" title="二、推送通知的类型"></a>二、推送通知的类型</h2><p>推送通知分为本地推送与远程推送</p>
<p>本地推送最大推送数量是64个，超过这个数量会被忽略</p>
<p>本地推送：不需要联网也可以推送，是开发人员在APP内设定特定的时间来提醒用户干什么</p>
<p>本地通知与远程通知都可以向不在前台运行的应用发送消息，这种消息既可能是即将发生的事件，也可能是服务器的新数据，不管是本地还是远程通知，他们在界面上的显示效果是相同的。</p>
<p>二者的区别是本地推送是由本应用负责调用，只能从当前设备上的iOS发出。而远程推送是由服务器来控制。</p>
<h2 id="三、推送通知的流程"><a href="#三、推送通知的流程" class="headerlink" title="三、推送通知的流程"></a>三、推送通知的流程</h2><ol>
<li><p>应用程序注册消息推送。</p>
</li>
<li><p>iOS从APNS Server获取device token，应用程序接收device token。 </p>
</li>
<li><p>应用程序将device token发送给PUSH服务端程序。</p>
</li>
<li><p>服务端程序向APNS服务发送消息。</p>
</li>
<li><p>APNS服务将消息发送给iPhone应用程序</p>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/08/06/iOS/OC/021-APNS/README/003.webp"
                     
                ></p>
<h3 id="1-推送前"><a href="#1-推送前" class="headerlink" title="1. 推送前"></a>1. 推送前</h3><ol>
<li><p>Device连接APNs服务器并携带设备序列号 </p>
</li>
<li><p>连接成功，APNs经过打包和处理产生device_token并返回给注册的Device </p>
</li>
<li><p>Device携带获取的device_token向我们自己的应用服务器注册 </p>
</li>
<li><p>完成需要推送的Device在APNs服务器和我们自己的应用服务器注册</p>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/08/06/iOS/OC/021-APNS/README/001.webp"
                     
                ></p>
<h3 id="2-推送中"><a href="#2-推送中" class="headerlink" title="2. 推送中"></a>2. 推送中</h3><ol>
<li><p>首先，安装了具有推送功能的应用，我们的设备在有网络的情况下会连接苹果推送服务器，连接过程中，APNS会验证device_token，连接成功后维持一个长连接； </p>
</li>
<li><p>Provider(我们自己的服务器)收到需要被推送的消息并结合被推送设备的device_token一起打包发送给APNS服务器； </p>
</li>
<li><p>APNS服务器将推送信息推送给指定device_token的设备； </p>
</li>
<li><p>设备收到推送消息后通知我们的应用程序并显示和提示用户（声音、弹出框）</p>
</li>
</ol>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/08/06/iOS/OC/021-APNS/README/002.webp"
                     
                ></p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>APNS</tag>
        <tag>推送</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS中Runloop应用场景</title>
    <url>/2024/08/09/iOS/OC/08-iOS%E7%BB%84%E4%BB%B6%E5%8C%96/index/</url>
    <content><![CDATA[<p><a class="link"   href="https://juejin.cn/post/6879980785177198606" >iOS组件化的那些事 - CTMediator <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>组件化</tag>
        <tag>CTMediator</tag>
      </tags>
  </entry>
  <entry>
    <title>Swift Kingfisher阅读</title>
    <url>/2024/08/09/iOS/Swift/08-%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/001-Kingfisher/index/</url>
    <content><![CDATA[<p><a class="link"   href="https://juejin.cn/post/6929345703818985485" >我是这样学习拥有18k⭐️的Kingfisher优秀代码的–亲自实战优化项目代码和结构【物超所值】 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Swift</tag>
        <tag>Kingfisher</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 属性关键字</title>
    <url>/2024/07/22/iOS/OC/001-OC%E5%B1%9E%E6%80%A7%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97/003-iOS%E5%B1%9E%E6%80%A7%E5%85%B3%E9%94%AE%E5%AD%97/README/</url>
    <content><![CDATA[<!-- # iOS 属性关键字 -->

<p>在iOS开发中，属性关键字用于修饰属性的行为和特性。理解和正确使用这些关键字可以帮助开发者更好地管理对象的内存和线程安全性。以下是常用的属性关键字及其解释：</p>
 <span id="more"></span>

<h3 id="内存管理关键字"><a href="#内存管理关键字" class="headerlink" title="内存管理关键字"></a>内存管理关键字</h3><ul>
<li><p><strong>strong</strong>：表示对对象的强引用，属性会持有对象，引用计数增加。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, strong) NSString *name;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>weak</strong>：表示对对象的弱引用，属性不会持有对象，引用计数不增加。如果对象被释放，weak引用会自动设置为nil，避免野指针。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, weak) id&lt;Delegate&gt; delegate;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>assign</strong>：直接赋值，不更改引用计数。通常用于基本数据类型或不需要持有的对象。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, assign) NSInteger age;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>copy</strong>：表示对对象进行拷贝，属性会持有拷贝后的对象。适用于NSString等类，为了防止属性被外部修改。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, copy) NSString *title;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>unsafe_unretained</strong>：与weak类似，但对象被释放后不会自动设置为nil，容易导致野指针。适用于不支持弱引用的对象（在ARC之前常用）。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, unsafe_unretained) id delegate;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="原子性关键字"><a href="#原子性关键字" class="headerlink" title="原子性关键字"></a>原子性关键字</h3><ul>
<li><p><strong>atomic</strong>：默认行为，确保属性的读写操作是线程安全的。性能较低，因为每次访问属性时都需要加锁。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property (atomic, strong) NSString *name;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>nonatomic</strong>：不保证线程安全，性能较高，适用于大多数场景。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, strong) NSString *name;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="属性的读写权限关键字"><a href="#属性的读写权限关键字" class="headerlink" title="属性的读写权限关键字"></a>属性的读写权限关键字</h3><ul>
<li><p><strong>readonly</strong>：只生成getter方法，不生成setter方法，属性只能读不能写。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, readonly) NSString *identifier;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>readwrite</strong>：生成getter和setter方法，属性可读可写。默认行为。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, readwrite) NSString *name;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="自定义方法名关键字"><a href="#自定义方法名关键字" class="headerlink" title="自定义方法名关键字"></a>自定义方法名关键字</h3><ul>
<li><p><strong>getter</strong>：自定义getter方法名。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, getter=isEnabled) BOOL enabled;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>setter</strong>：自定义setter方法名。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, setter=setEnabled:) BOOL enabled;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="内存管理策略（在MRC中使用）"><a href="#内存管理策略（在MRC中使用）" class="headerlink" title="内存管理策略（在MRC中使用）"></a>内存管理策略（在MRC中使用）</h3><ul>
<li><p><strong>retain</strong>：表示对对象的强引用，属性会持有对象，引用计数增加。ARC环境下用strong代替。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, retain) NSString *name;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>assign</strong>：直接赋值，不更改引用计数。ARC环境下用weak或assign代替。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, assign) NSInteger age;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>copy</strong>：表示对对象进行拷贝，属性会持有拷贝后的对象。ARC环境下与strong结合使用。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, copy) NSString *title;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="特殊关键字"><a href="#特殊关键字" class="headerlink" title="特殊关键字"></a>特殊关键字</h3><ul>
<li><p><strong>nonnull</strong>：表示属性不能为空。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, strong, nonnull) NSString *name;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>nullable</strong>：表示属性可以为空。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, strong, nullable) NSString *name;</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>null_resettable</strong>：属性可以为空，但在访问时会自动初始化。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, strong, null_resettable) UIView *view;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>理解和正确使用属性关键字，可以有效管理内存、提高性能和确保线程安全。根据不同的场景选择合适的关键字，可以让代码更加健壮和高效。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>属性关键字</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS ARC 下 所有权修饰符</title>
    <url>/2024/07/22/iOS/OC/001-OC%E5%B1%9E%E6%80%A7%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97/005-ARC%E4%B8%8B%E6%89%80%E6%9C%89%E6%9D%83%E4%BF%AE%E9%A5%B0%E7%AC%A6/README/</url>
    <content><![CDATA[<!-- # iOS ARC 下 所有权修饰符 -->

<p>在 iOS 的 ARC（Automatic Reference Counting）环境下，所有权修饰符用于指定对象的内存管理策略。ARC 自动处理对象的引用计数，但开发者可以通过使用这些修饰符来显式地控制对象的生命周期和内存管理。以下是常用的 ARC 所有权修饰符及其详细解释：</p>
<span id="more"></span>

<h3 id="1-strong"><a href="#1-strong" class="headerlink" title="1. __strong"></a>1. <code>__strong</code></h3><ul>
<li><strong>作用</strong>：表示对对象的强引用，持有对象。对象的引用计数会增加，直到所有对它的 <code>strong</code> 引用都被释放，才会被销毁。</li>
<li><strong>默认行为</strong>：在 ARC 环境中，默认情况下所有对象都是 <code>__strong</code>，即使不显式声明。</li>
<li><strong>使用场景</strong>：适用于需要长期持有的对象，如模型对象、视图控制器的子视图等。</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 默认情况下，所有对象都是 __strong</span><br><span class="line">__strong NSString *name = [[NSString alloc] init];</span><br></pre></td></tr></table></figure></div>

<h3 id="2-weak"><a href="#2-weak" class="headerlink" title="2. __weak"></a>2. <code>__weak</code></h3><ul>
<li><strong>作用</strong>：表示对对象的弱引用，不持有对象。对象的引用计数不会增加，当对象被销毁时，weak 属性会自动设置为 nil，避免悬空指针（dangling pointer）。</li>
<li><strong>使用场景</strong>：用于避免循环引用（如 <code>delegate</code>、<code>IBOutlet</code>）。</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 使用 __weak 避免循环引用</span><br><span class="line">__weak id&lt;Delegate&gt; delegate = self.delegate;</span><br></pre></td></tr></table></figure></div>

<h3 id="3-unsafe-unretained"><a href="#3-unsafe-unretained" class="headerlink" title="3. __unsafe_unretained"></a>3. <code>__unsafe_unretained</code></h3><ul>
<li><strong>作用</strong>：类似于 <code>__weak</code>，但对象被销毁时不会自动设置为 nil，可能导致悬空指针。适用于不支持弱引用的对象。</li>
<li><strong>使用场景</strong>：在特定情况下需要使用非 ARC 环境下不需要弱引用的对象，但需要小心避免悬空指针。</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 使用 __unsafe_unretained，可能导致悬空指针</span><br><span class="line">__unsafe_unretained id delegate = self.delegate;</span><br></pre></td></tr></table></figure></div>

<h3 id="4-autoreleasing"><a href="#4-autoreleasing" class="headerlink" title="4. __autoreleasing"></a>4. <code>__autoreleasing</code></h3><ul>
<li><strong>作用</strong>：表示对象会被放入自动释放池中，在当前作用域结束时被释放。通常用于方法参数和返回值，以确保临时对象被自动释放。</li>
<li><strong>使用场景</strong>：在处理 <code>NSError</code> 和其他双指针参数（如 <code>id *</code>）时。</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (BOOL)performOperationWithError:(NSError * __autoreleasing *)error &#123;</span><br><span class="line">    if (/* some failure condition */) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            *error = [NSError errorWithDomain:@&quot;com.example&quot; code:42 userInfo:nil];</span><br><span class="line">        &#125;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下示例展示了 <code>__strong</code>、<code>__weak</code>、<code>__unsafe_unretained</code> 和 <code>__autoreleasing</code> 的使用：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface MyClass : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSString *strongName;</span><br><span class="line">@property (nonatomic, weak) id&lt;Delegate&gt; weakDelegate;</span><br><span class="line">@property (nonatomic, unsafe_unretained) id unsafeDelegate;</span><br><span class="line"></span><br><span class="line">- (BOOL)performOperationWithError:(NSError * __autoreleasing *)error;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MyClass</span><br><span class="line"></span><br><span class="line">- (void)example &#123;</span><br><span class="line">    // __strong 变量，持有对象</span><br><span class="line">    __strong NSString *strongString = [[NSString alloc] initWithString:@&quot;Hello&quot;];</span><br><span class="line">    </span><br><span class="line">    // __weak 变量，不持有对象，当对象被销毁时自动设置为 nil</span><br><span class="line">    __weak NSString *weakString = strongString;</span><br><span class="line">    </span><br><span class="line">    // __unsafe_unretained 变量，不持有对象，当对象被销毁时不会自动设置为 nil</span><br><span class="line">    __unsafe_unretained NSString *unsafeString = strongString;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;strongString: %@&quot;, strongString);</span><br><span class="line">    NSLog(@&quot;weakString: %@&quot;, weakString);</span><br><span class="line">    NSLog(@&quot;unsafeString: %@&quot;, unsafeString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (BOOL)performOperationWithError:(NSError * __autoreleasing *)error &#123;</span><br><span class="line">    if (/* some failure condition */) &#123;</span><br><span class="line">        if (error) &#123;</span><br><span class="line">            *error = [NSError errorWithDomain:@&quot;com.example&quot; code:42 userInfo:nil];</span><br><span class="line">        &#125;</span><br><span class="line">        return NO;</span><br><span class="line">    &#125;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>**<code>__strong</code>**：默认行为，适用于大多数场景，确保对象被持有。</li>
<li>**<code>__weak</code>**：用于避免循环引用，适用于 <code>delegate</code>、<code>IBOutlet</code> 等。</li>
<li>**<code>__unsafe_unretained</code>**：需要小心使用，避免悬空指针。推荐在 ARC 环境下尽量使用 <code>__weak</code> 代替。</li>
<li>**<code>__autoreleasing</code>**：用于方法参数和返回值，确保临时对象被自动释放。</li>
</ul>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>修饰符</tag>
      </tags>
  </entry>
  <entry>
    <title>请问 @property 的本质是什么？</title>
    <url>/2024/07/22/iOS/OC/001-OC%E5%B1%9E%E6%80%A7%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97/008-@property%E7%9A%84%E6%9C%AC%E8%B4%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/README/</url>
    <content><![CDATA[<!-- # @property 的本质是什么？ -->

<p>在 Objective-C 中，<code>@property</code> 是一种用于声明类的属性的语法糖。<strong>它的本质是帮助开发者自动生成属性的 getter 和 setter 方法，以及属性所需的实例变量（ivar）。</strong><code>@property</code> 使得代码更简洁、可读性更高，并且减少了手动编写 getter 和 setter 方法的繁琐工作。为了更详细地理解 <code>@property</code> 的本质，下面从几个方面进行解释：</p>
<span id="more"></span>

<h3 id="property-的基本组成部分"><a href="#property-的基本组成部分" class="headerlink" title="@property 的基本组成部分"></a><code>@property</code> 的基本组成部分</h3><p>当你在类中声明一个属性时：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface MyClass : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSString *name;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div>

<p><code>@property</code> 包含以下几个部分：</p>
<ul>
<li><strong>属性特性（Attributes）</strong>：如 <code>nonatomic</code>、<code>strong</code>，用于指定属性的行为。</li>
<li><strong>类型（Type）</strong>：如 <code>NSString *</code>，指定属性的数据类型。</li>
<li><strong>属性名（Name）</strong>：如 <code>name</code>，指定属性的名称。</li>
</ul>
<h3 id="property-的工作原理"><a href="#property-的工作原理" class="headerlink" title="@property 的工作原理"></a><code>@property</code> 的工作原理</h3><p>在编译时，<code>@property</code> 会生成与之相关的实例变量、getter 和 setter 方法。以上面的例子为例，<code>@property (nonatomic, strong) NSString *name;</code> 将生成以下内容：</p>
<h4 id="1-实例变量"><a href="#1-实例变量" class="headerlink" title="1. 实例变量"></a>1. 实例变量</h4><p>编译器生成一个名为 <code>_name</code> 的实例变量（ivar）：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface MyClass : NSObject &#123;</span><br><span class="line">    NSString *_name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="2-Getter-方法"><a href="#2-Getter-方法" class="headerlink" title="2. Getter 方法"></a>2. Getter 方法</h4><p>编译器生成一个名为 <code>name</code> 的 getter 方法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (NSString *)name &#123;</span><br><span class="line">    return _name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h4 id="3-Setter-方法"><a href="#3-Setter-方法" class="headerlink" title="3. Setter 方法"></a>3. Setter 方法</h4><p>编译器生成一个名为 <code>setName:</code> 的 setter 方法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (void)setName:(NSString *)newName &#123;</span><br><span class="line">    if (_name != newName) &#123;</span><br><span class="line">        [_name release];</span><br><span class="line">        _name = [newName retain];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="property-的属性特性"><a href="#property-的属性特性" class="headerlink" title="@property 的属性特性"></a><code>@property</code> 的属性特性</h3><p><code>@property</code> 可以通过属性特性来控制生成的 getter 和 setter 的行为。常用的属性特性包括：</p>
<ul>
<li><strong>atomic &#x2F; nonatomic</strong>：决定属性的原子性。<code>atomic</code> 保证多线程环境下的安全，但性能较低；<code>nonatomic</code> 性能较高，但不保证线程安全。</li>
<li><strong>strong &#x2F; weak &#x2F; assign &#x2F; copy</strong>：指定属性的内存管理语义。</li>
<li><strong>readonly &#x2F; readwrite</strong>：指定属性是否只读。默认是 <code>readwrite</code>，可以生成 getter 和 setter；<code>readonly</code> 只生成 getter。</li>
<li><strong>getter &#x2F; setter</strong>：指定自定义的 getter 和 setter 方法名。</li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, strong) NSString *name;</span><br><span class="line">@property (nonatomic, weak) id&lt;Delegate&gt; delegate;</span><br><span class="line">@property (nonatomic, assign) NSInteger age;</span><br><span class="line">@property (nonatomic, copy) NSString *title;</span><br><span class="line">@property (nonatomic, readonly) NSString *identifier;</span><br><span class="line">@property (getter=isValid, setter=setValid:) BOOL valid;</span><br></pre></td></tr></table></figure></div>

<h3 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h3><p>假设你有以下代码：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface MyClass : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSString *name;</span><br><span class="line">@property (nonatomic, readonly) NSString *identifier;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MyClass</span><br><span class="line"></span><br><span class="line">@synthesize name = _name; // 手动指定实例变量名</span><br><span class="line">@synthesize identifier = _identifier; // 手动指定只读属性的实例变量名</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div>

<p>这段代码：</p>
<ol>
<li>为 <code>name</code> 属性生成 <code>_name</code> 实例变量、getter 和 setter 方法。</li>
<li>为 <code>identifier</code> 属性生成 <code>_identifier</code> 实例变量和 getter 方法。</li>
</ol>
<p>如果没有使用 <code>@synthesize</code>，编译器会自动合成这些方法和实例变量。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>@property</code> 的本质是一个语法糖，它在编译时自动生成与属性相关的实例变量、getter 和 setter 方法。通过使用 <code>@property</code>，开发者可以简化代码，提高可读性和可维护性。理解 <code>@property</code> 的本质和工作原理，有助于更好地掌握 Objective-C 的内存管理和编程技巧。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>property</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么UITableView的delegate属性修饰符assign</title>
    <url>/2024/07/22/iOS/OC/001-OC%E5%B1%9E%E6%80%A7%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97/004-%E4%B8%BA%E4%BB%80%E4%B9%88UITableView%E7%9A%84delegate%E5%B1%9E%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6assign/README/</url>
    <content><![CDATA[<!-- # 为什么UITableView的delegate属性修饰符assign -->

<p>在早期的 iOS 开发中，<code>UITableView</code> 的 <code>delegate</code> 属性使用 <code>assign</code> 修饰符是为了避免循环引用（retain cycle）。以下是详细解释：</p>
<span id="more"></span>

<h3 id="循环引用问题"><a href="#循环引用问题" class="headerlink" title="循环引用问题"></a>循环引用问题</h3><p><code>delegate</code> 通常用于代理模式，这种模式在 iOS 开发中非常常见。代理对象通常是视图控制器，而被代理的对象是视图组件（如 <code>UITableView</code>）。如果 <code>delegate</code> 属性使用 <code>strong</code> 或 <code>retain</code>，会导致以下循环引用：</p>
<ul>
<li>视图控制器（ViewController）持有 <code>UITableView</code> 对象的强引用。</li>
<li><code>UITableView</code> 对象又通过 <code>delegate</code> 属性持有视图控制器的强引用。</li>
</ul>
<p>这样，两者之间互相持有对方的强引用，导致内存无法释放，形成循环引用（retain cycle）。</p>
<h3 id="使用-assign-修饰符"><a href="#使用-assign-修饰符" class="headerlink" title="使用 assign 修饰符"></a>使用 <code>assign</code> 修饰符</h3><p>为了解决这个问题，<code>delegate</code> 属性在早期使用 <code>assign</code> 修饰符：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, assign) id&lt;UITableViewDelegate&gt; delegate;</span><br></pre></td></tr></table></figure></div>

<ul>
<li><strong>assign</strong>：直接赋值，不更改引用计数。这样 <code>UITableView</code> 对象对 <code>delegate</code>（通常是视图控制器）的引用不会增加引用计数，从而避免了循环引用。</li>
</ul>
<h3 id="从-assign-到-weak"><a href="#从-assign-到-weak" class="headerlink" title="从 assign 到 weak"></a>从 <code>assign</code> 到 <code>weak</code></h3><p>在ARC（Automatic Reference Counting）引入之后，苹果推荐使用 <code>weak</code> 修饰符来代替 <code>assign</code>。<code>weak</code> 属性不仅可以避免循环引用，还能在目标对象被释放时自动将指针置为 <code>nil</code>，避免悬空指针（dangling pointer）的问题。</p>
<p>因此，现代的 iOS 开发中，<code>UITableView</code> 的 <code>delegate</code> 属性一般使用 <code>weak</code> 修饰符：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, weak) id&lt;UITableViewDelegate&gt; delegate;</span><br></pre></td></tr></table></figure></div>

<p>这样，<code>UITableView</code> 对 <code>delegate</code> 的引用不会增加引用计数，并且在 <code>delegate</code> 被释放时自动置为 <code>nil</code>，更加安全。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>早期的 <code>delegate</code> 属性使用 <code>assign</code> 是为了避免循环引用，防止内存泄漏。</li>
<li>ARC 引入后，推荐使用 <code>weak</code> 修饰符，既避免循环引用，又防止悬空指针问题。</li>
</ul>
<p>因此，在现代 iOS 开发中，<code>UITableView</code> 和其他视图组件的 <code>delegate</code> 属性通常使用 <code>weak</code> 修饰符。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>delegate</tag>
        <tag>UITableView</tag>
        <tag>assign</tag>
      </tags>
  </entry>
  <entry>
    <title>请问 @synthesize 和 @dynamic 分别有什么作用？</title>
    <url>/2024/07/22/iOS/OC/001-OC%E5%B1%9E%E6%80%A7%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97/009-@synthesize%E5%92%8C@dynamic%E5%88%86%E5%88%AB%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F/README/</url>
    <content><![CDATA[<!-- # @synthesize 和 @dynamic 分别有什么作用？ -->

<p>在 Objective-C 中，<code>@synthesize</code> 和 <code>@dynamic</code> 是用来辅助属性（<code>@property</code>）的实现的关键字。它们在处理属性的 getter 和 setter 方法时具有不同的作用和用途。</p>
<span id="more"></span>

<h3 id="synthesize"><a href="#synthesize" class="headerlink" title="@synthesize"></a><code>@synthesize</code></h3><p><code>@synthesize</code> 用于自动生成属性的 getter 和 setter 方法。如果你不手动实现这些方法，编译器会根据 <code>@synthesize</code> 来生成默认的实现。使用 <code>@synthesize</code> 时，你还可以指定属性的实例变量名。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface MyClass : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSString *name;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MyClass</span><br><span class="line"></span><br><span class="line">// 自动生成 _name 实例变量、getter 和 setter 方法</span><br><span class="line">@synthesize name = _name;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div>

<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul>
<li><strong>自动生成 getter 和 setter 方法</strong>：<code>@synthesize</code> 告诉编译器自动为属性生成相应的 getter 和 setter 方法。</li>
<li><strong>指定实例变量名</strong>：可以用 <code>@synthesize propertyName = instanceVariableName</code> 的形式来指定属性对应的实例变量名。</li>
</ul>
<h4 id="默认行为"><a href="#默认行为" class="headerlink" title="默认行为"></a>默认行为</h4><p>如果不显式使用 <code>@synthesize</code>，编译器会默认合成实例变量和相应的 getter、setter 方法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface MyClass : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSString *name;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MyClass</span><br><span class="line"></span><br><span class="line">// 默认情况下，编译器会自动生成 _name 实例变量和方法</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div>

<h3 id="dynamic"><a href="#dynamic" class="headerlink" title="@dynamic"></a><code>@dynamic</code></h3><p><code>@dynamic</code> 告诉编译器不要自动生成属性的 getter 和 setter 方法，开发者需要在运行时动态地提供这些方法的实现。通常用于 Core Data 或其他需要在运行时动态处理属性的场景。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface MyClass : NSObject</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSString *name;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MyClass</span><br><span class="line"></span><br><span class="line">@dynamic name;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div>

<h4 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h4><ul>
<li><strong>禁用自动生成</strong>：<code>@dynamic</code> 禁用编译器对属性自动生成的 getter 和 setter 方法。</li>
<li><strong>运行时提供实现</strong>：开发者需要在运行时通过手动实现或其他方式提供 getter 和 setter 方法。</li>
</ul>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li><strong>Core Data</strong>：在使用 Core Data 时，属性的实现通常由 Core Data 动态提供，而不是由编译器自动生成。</li>
<li><strong>动态方法解析</strong>：在某些高级用例中，开发者可能需要使用 <code>@dynamic</code> 并手动实现 <code>resolveInstanceMethod:</code> 或消息转发机制。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><p>**<code>@synthesize</code>**：</p>
<ul>
<li>用于自动生成属性的 getter 和 setter 方法。</li>
<li>可以指定属性的实例变量名。</li>
<li>如果不显式使用，编译器会默认合成。</li>
</ul>
</li>
<li><p>**<code>@dynamic</code>**：</p>
<ul>
<li>告诉编译器不要自动生成 getter 和 setter 方法。</li>
<li>需要在运行时动态提供方法的实现。</li>
<li>通常用于 Core Data 或其他需要动态处理属性的场景。</li>
</ul>
</li>
</ul>
<p>通过理解 <code>@synthesize</code> 和 <code>@dynamic</code> 的作用和使用场景，开发者可以更灵活地管理属性的实现，满足不同的编程需求。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>synthesize</tag>
        <tag>dynamic</tag>
      </tags>
  </entry>
  <entry>
    <title>对象回收时 weak 指针自动被置为 nil 是如何实现的？</title>
    <url>/2024/07/22/iOS/OC/001-OC%E5%B1%9E%E6%80%A7%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97/010-weak%E6%8C%87%E9%92%88%E8%A2%AB%E8%87%AA%E5%8A%A8%E7%BD%AE%E4%B8%BAnil%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%EF%BC%9F/README/</url>
    <content><![CDATA[<!-- # 对象回收时 weak 指针自动被置为 nil 是如何实现的？ -->

<p>在 iOS的自动引用计数（ARC）机制中，当对象被回收时，所有指向该对象的 <code>__weak</code> 指针都会被自动置为 <code>nil</code>。这个功能是通过Objective-C运行时（runtime）的弱引用表（weak reference table）实现的。以下是实现这一功能的详细机制：</p>
<span id="more"></span>

<h3 id="1-弱引用表（Weak-Reference-Table）"><a href="#1-弱引用表（Weak-Reference-Table）" class="headerlink" title="1. 弱引用表（Weak Reference Table）"></a>1. 弱引用表（Weak Reference Table）</h3><p>Objective-C运行时维护了一张全局的弱引用表，这张表记录了所有的弱引用。当创建一个弱引用时，这个弱引用会被添加到弱引用表中。</p>
<h3 id="2-创建弱引用"><a href="#2-创建弱引用" class="headerlink" title="2. 创建弱引用"></a>2. 创建弱引用</h3><p>当你创建一个弱引用时，例如：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">__weak MyClass *weakRef = strongRef;</span><br></pre></td></tr></table></figure></div>

<p>ARC 会在弱引用表中添加一个条目，记录 <code>weakRef</code> 指向的对象地址以及 <code>weakRef</code> 本身的地址。这个条目让运行时知道哪些弱引用指向了某个对象。</p>
<h3 id="3-对象销毁"><a href="#3-对象销毁" class="headerlink" title="3. 对象销毁"></a>3. 对象销毁</h3><p>当一个对象的引用计数降到零时，ARC 会释放这个对象。在释放对象之前，运行时会查阅弱引用表，找到所有指向这个对象的弱引用，并将它们置为 <code>nil</code>。</p>
<h3 id="4-实现细节"><a href="#4-实现细节" class="headerlink" title="4. 实现细节"></a>4. 实现细节</h3><p>具体实现涉及以下步骤：</p>
<ul>
<li><p><strong>添加弱引用</strong>：<br>当创建弱引用时，ARC 通过调用 <code>objc_storeWeak</code> 函数将弱引用存储在弱引用表中。</p>
</li>
<li><p><strong>释放对象</strong>：<br>当对象引用计数降到零时，ARC 通过调用 <code>objc_release</code> 函数来处理对象的释放。在释放之前，会调用 <code>clearDeallocating</code> 函数。</p>
</li>
<li><p><strong>清理弱引用</strong>：<br><code>clearDeallocating</code> 函数会查找弱引用表中所有指向即将销毁的对象的弱引用，并将它们置为 <code>nil</code>。这个过程包括以下步骤：</p>
<ul>
<li>查找弱引用表中的条目。</li>
<li>将每个弱引用的值设置为 <code>nil</code>。</li>
<li>从弱引用表中移除这些条目。</li>
</ul>
</li>
</ul>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>以下是一个简单的示例，演示了弱引用自动置为 <code>nil</code> 的行为：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface MyClass : NSObject</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MyClass</span><br><span class="line">- (void)dealloc &#123;</span><br><span class="line">    NSLog(@&quot;MyClass instance is being deallocated&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        MyClass *strongRef = [[MyClass alloc] init];</span><br><span class="line">        __weak MyClass *weakRef = strongRef;</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;Before setting strongRef to nil: weakRef = %@&quot;, weakRef);</span><br><span class="line">        </span><br><span class="line">        strongRef = nil; // MyClass instance is deallocated</span><br><span class="line">        </span><br><span class="line">        NSLog(@&quot;After setting strongRef to nil: weakRef = %@&quot;, weakRef);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>输出：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Before setting strongRef to nil: weakRef = &lt;MyClass: 0x100508ee0&gt;</span><br><span class="line">MyClass instance is being deallocated</span><br><span class="line">After setting strongRef to nil: weakRef = (null)</span><br></pre></td></tr></table></figure></div>

<h3 id="内部机制"><a href="#内部机制" class="headerlink" title="内部机制"></a>内部机制</h3><p>以下是一些关键函数和概念，用于实现弱引用自动置为 <code>nil</code> 的机制：</p>
<ul>
<li><p><strong>objc_storeWeak</strong>：<br>这个函数用于存储弱引用，并在弱引用表中注册这个弱引用。</p>
</li>
<li><p><strong>clearDeallocating</strong>：<br>当对象引用计数降到零时，这个函数会被调用，用于清理弱引用表中的条目。</p>
</li>
<li><p><strong>弱引用表</strong>：<br>运行时维护的全局哈希表，用于存储所有弱引用的地址和它们指向的对象。</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>弱引用自动置为 <code>nil</code> 的机制是通过 Objective-C 运行时的弱引用表实现的。当对象被回收时，运行时会查找并清理所有指向该对象的弱引用，将它们置为 <code>nil</code>。这个机制确保了弱引用不会悬挂，避免了潜在的崩溃和未定义行为。理解这一机制有助于更好地掌握 ARC 和内存管理。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>weak</tag>
      </tags>
  </entry>
  <entry>
    <title>怎么用 copy 关键字？</title>
    <url>/2024/07/22/iOS/OC/001-OC%E5%B1%9E%E6%80%A7%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97/012-copy%E5%85%B3%E9%94%AE%E5%AD%97/README/</url>
    <content><![CDATA[<!-- # 怎么用 copy 关键字？ -->

<ul>
<li>NSString、NSArray、NSDictionary等等经常使用copy关键字，是因为他们有对应的可变类型：NSMutableString、NSMutableArray、NSMutableDictionary，为确保对象中的属性值不会无意间变动，应该在设置新属性值时拷贝一份，保护其封装性</li>
<li>block也经常使用copy关键字<ul>
<li>block 使用 copy 是从 MRC 遗留下来的“传统”,在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.</li>
<li>在ARC中写不写都行：对于 block 使用 copy 还是 strong 效果是一样的，但是建议写上copy，因为这样显示告知调用者“编译器会自动对 block 进行了 copy 操作”</li>
</ul>
</li>
</ul>
<span id="more"></span>


<p>假如有一个NSMutableString,现在用他给一个retain修饰 NSString赋值,那么只是将NSString指向了NSMutableString所指向的位置,并对NSMUtbaleString计数器加一,此时,如果对NSMutableString进行修改,也会导致NSString的值修改,原则上这是不允许的. 如果是copy修饰的NSString对象,在用NSMutableString给他赋值时,会进行深拷贝,及把内容也给拷贝了一份,两者指向不同的位置,即使改变了NSMutableString的值,NSString的值也不会改变.</p>
<p>所以用copy是为了安全,防止NSMutableString赋值给NSString时,前者修改引起后者值变化而用的.</p>
<p>strong修饰NSString</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, strong) NSString *name;</span><br><span class="line"></span><br><span class="line">- (void)string_strong &#123;</span><br><span class="line">    NSMutableString *mStr = [NSMutableString stringWithString:@&quot;张三&quot;];</span><br><span class="line"></span><br><span class="line">    self.name = mStr;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;使用strong第一次得到的名字：%@&quot;, self.name);</span><br><span class="line"></span><br><span class="line">    [mStr appendString:@&quot;丰&quot;];</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;使用strong第二次得到的名字：%@&quot;, self.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">使用strong第一次得到的名字：张三</span><br><span class="line">使用strong第二次得到的名字：张三丰</span><br></pre></td></tr></table></figure></div>





<p>copy修饰NSString</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property (nonatomic, copy) NSString *title;</span><br><span class="line"></span><br><span class="line">- (void)string_copy &#123;</span><br><span class="line">    </span><br><span class="line">    NSMutableString *mStr = [NSMutableString stringWithString:@&quot;张三&quot;];</span><br><span class="line"></span><br><span class="line">    self.title = mStr;</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;使用copy第一次得到的名字：%@&quot;, self.title);</span><br><span class="line"></span><br><span class="line">    [mStr appendString:@&quot;丰&quot;];</span><br><span class="line"></span><br><span class="line">    NSLog(@&quot;使用copy第二次得到的名字：%@&quot;, self.title);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">使用copy第一次得到的名字：张三</span><br><span class="line">使用copy第二次得到的名字：张三</span><br></pre></td></tr></table></figure></div>





<h1 id="这个写法会出什么问题：-property-copy-NSMutableArray-arr"><a href="#这个写法会出什么问题：-property-copy-NSMutableArray-arr" class="headerlink" title="这个写法会出什么问题：@property (copy) NSMutableArray *arr;"></a>这个写法会出什么问题：@property (copy) NSMutableArray *arr;</h1><ol>
<li>atomic 属性会影响性能；</li>
<li>由于copy复制了一个不可变的NSArray对象，如果对arr进行添加、删除、修改数组内部元素的时候，程序找不到对应的方法而崩溃；</li>
</ol>
<div class="highlight-container" data-rel="Objc"><figure class="iseeu highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSMutableString</span> *testStr;</span><br><span class="line"></span><br><span class="line">- (<span class="type">void</span>)mutableString_copy &#123;</span><br><span class="line">    <span class="built_in">NSMutableString</span> *mStr = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@&quot;张三&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.testStr = mStr;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;使用copy第一次得到的名字：%@&quot;</span>, <span class="keyword">self</span>.testStr);</span><br><span class="line"></span><br><span class="line">    [mStr appendString:<span class="string">@&quot;丰&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;使用copy第二次得到的名字：%@&quot;</span>, <span class="keyword">self</span>.testStr);</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.testStr appendString:<span class="string">@&quot;123&quot;</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;使用copy第三次得到的名字：%@&quot;</span>, <span class="keyword">self</span>.testStr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">使用<span class="keyword">copy</span>第一次得到的名字：张三</span><br><span class="line">使用<span class="keyword">copy</span>第一次得到的名字：张三</span><br><span class="line">Terminating app due to uncaught exception <span class="string">&#x27;NSInvalidArgumentException&#x27;</span>, reason: <span class="string">&#x27;Attempt to mutate immutable object with appendString:&#x27;</span>.........</span><br><span class="line"></span><br><span class="line"><span class="comment">// 崩溃原因</span></span><br><span class="line">由于<span class="keyword">copy</span>复制了一个不可变的<span class="built_in">NSArray</span>对象，如果对arr进行添加、删除、修改数组内部元素的时候，程序找不到对应的方法而崩溃。</span><br></pre></td></tr></table></figure></div>





<h1 id="如何让自己的类用-copy-修饰符？"><a href="#如何让自己的类用-copy-修饰符？" class="headerlink" title="如何让自己的类用 copy 修饰符？"></a>如何让自己的类用 copy 修饰符？</h1><ol>
<li><p>需要声明该类遵从NSCopying 或 NSMutableCopying协议；</p>
</li>
<li><p>实现NSCopying协议，该协议只有一个方法：<code>-(id)copyWithZone:(NSZone *)zone;</code></p>
</li>
</ol>
<ul>
<li><p><strong>拓展</strong></p>
<p>  copy：不可变拷贝,遵循NSCopying协议，需要对应实现copyWithZone方法；</p>
<p>  mutableCopy：可变拷贝，遵循NSMutableCopying协议，需要对应实现mutableCopyWithZone:方法；</p>
</li>
</ul>
<h1 id="对于深拷贝和浅拷贝的理解"><a href="#对于深拷贝和浅拷贝的理解" class="headerlink" title="对于深拷贝和浅拷贝的理解"></a>对于深拷贝和浅拷贝的理解</h1><p>系统对象 NSString&#x2F;NSMutableString&#x2F;NSArray&#x2F;NSMutableArray 的 copy 与 mutableCopy 方法。</p>
<p>在 iOS 开发中，<code>NSString</code>、<code>NSMutableString</code>、<code>NSArray</code> 和 <code>NSMutableArray</code> 都是非常常用的对象。这些对象都有 <code>copy</code> 和 <code>mutableCopy</code> 方法，用于创建不可变副本或可变副本。理解这些方法的行为对于正确处理对象的拷贝和内存管理至关重要。</p>
<h3 id="copy-与-mutableCopy-方法"><a href="#copy-与-mutableCopy-方法" class="headerlink" title="copy 与 mutableCopy 方法"></a><code>copy</code> 与 <code>mutableCopy</code> 方法</h3><ul>
<li>**<code>copy</code>**：创建对象的不可变副本。如果对象本身是不可变的，那么 <code>copy</code> 方法通常会返回对象本身。</li>
<li>**<code>mutableCopy</code>**：创建对象的可变副本，不论对象本身是否可变。</li>
</ul>
<h3 id="NSString-和-NSMutableString"><a href="#NSString-和-NSMutableString" class="headerlink" title="NSString 和 NSMutableString"></a>NSString 和 NSMutableString</h3><h4 id="NSString"><a href="#NSString" class="headerlink" title="NSString"></a>NSString</h4><ul>
<li><code>copy</code>：返回对象本身，因为 <code>NSString</code> 是不可变的。</li>
<li><code>mutableCopy</code>：返回一个新的 <code>NSMutableString</code> 对象。</li>
</ul>
<div class="highlight-container" data-rel="Objc"><figure class="iseeu highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *originalString = <span class="string">@&quot;Hello, World!&quot;</span>;</span><br><span class="line"><span class="built_in">NSString</span> *stringCopy = [originalString <span class="keyword">copy</span>]; <span class="comment">// 返回原对象本身</span></span><br><span class="line"><span class="built_in">NSMutableString</span> *mutableStringCopy = [originalString mutableCopy]; <span class="comment">// 返回新的 NSMutableString 对象</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/22/iOS/OC/001-OC%E5%B1%9E%E6%80%A7%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97/012-copy%E5%85%B3%E9%94%AE%E5%AD%97/README/001.png"
                     
                ></p>
<h4 id="NSMutableString"><a href="#NSMutableString" class="headerlink" title="NSMutableString"></a>NSMutableString</h4><ul>
<li><code>copy</code>：返回一个新的 <code>NSString</code> 对象，因为 <code>NSMutableString</code> 是可变的。</li>
<li><code>mutableCopy</code>：返回一个新的 <code>NSMutableString</code> 对象。</li>
</ul>
<div class="highlight-container" data-rel="Objc"><figure class="iseeu highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableString</span> *originalMutableString = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@&quot;Hello, World!&quot;</span>];</span><br><span class="line"><span class="built_in">NSString</span> *stringCopy = [originalMutableString <span class="keyword">copy</span>]; <span class="comment">// 返回新的 NSString 对象</span></span><br><span class="line"><span class="built_in">NSMutableString</span> *mutableStringCopy = [originalMutableString mutableCopy]; <span class="comment">// 返回新的 NSMutableString 对象</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/22/iOS/OC/001-OC%E5%B1%9E%E6%80%A7%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97/012-copy%E5%85%B3%E9%94%AE%E5%AD%97/README/002.png"
                     
                ></p>
<h3 id="NSArray-和-NSMutableArray"><a href="#NSArray-和-NSMutableArray" class="headerlink" title="NSArray 和 NSMutableArray"></a>NSArray 和 NSMutableArray</h3><h4 id="NSArray"><a href="#NSArray" class="headerlink" title="NSArray"></a>NSArray</h4><ul>
<li><code>copy</code>：返回对象本身，因为 <code>NSArray</code> 是不可变的。</li>
<li><code>mutableCopy</code>：返回一个新的 <code>NSMutableArray</code> 对象。</li>
</ul>
<div class="highlight-container" data-rel="Objc"><figure class="iseeu highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *originalArray = @[<span class="string">@&quot;One&quot;</span>, <span class="string">@&quot;Two&quot;</span>, <span class="string">@&quot;Three&quot;</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *arrayCopy = [originalArray <span class="keyword">copy</span>]; <span class="comment">// 返回原对象本身</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *mutableArrayCopy = [originalArray mutableCopy]; <span class="comment">// 返回新的 NSMutableArray 对象</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/22/iOS/OC/001-OC%E5%B1%9E%E6%80%A7%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97/012-copy%E5%85%B3%E9%94%AE%E5%AD%97/README/003.png"
                     
                ></p>
<h4 id="NSMutableArray"><a href="#NSMutableArray" class="headerlink" title="NSMutableArray"></a>NSMutableArray</h4><ul>
<li><code>copy</code>：返回一个新的 <code>NSArray</code> 对象，因为 <code>NSMutableArray</code> 是可变的。</li>
<li><code>mutableCopy</code>：返回一个新的 <code>NSMutableArray</code> 对象。</li>
</ul>
<div class="highlight-container" data-rel="Objc"><figure class="iseeu highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSMutableArray</span> *originalMutableArray = [<span class="built_in">NSMutableArray</span> arrayWithArray:@[<span class="string">@&quot;One&quot;</span>, <span class="string">@&quot;Two&quot;</span>, <span class="string">@&quot;Three&quot;</span>]];</span><br><span class="line"><span class="built_in">NSArray</span> *arrayCopy = [originalMutableArray <span class="keyword">copy</span>]; <span class="comment">// 返回新的 NSArray 对象</span></span><br><span class="line"><span class="built_in">NSMutableArray</span> *mutableArrayCopy = [originalMutableArray mutableCopy]; <span class="comment">// 返回新的 NSMutableArray 对象</span></span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/22/iOS/OC/001-OC%E5%B1%9E%E6%80%A7%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97/012-copy%E5%85%B3%E9%94%AE%E5%AD%97/README/004.png"
                     
                ></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>对于不可变对象（如 <code>NSString</code> 和 <code>NSArray</code>），<code>copy</code> 方法返回原对象本身，而 <code>mutableCopy</code> 方法返回一个新的可变对象。</li>
<li>对于可变对象（如 <code>NSMutableString</code> 和 <code>NSMutableArray</code>），<code>copy</code> 方法返回一个新的不可变对象，而 <code>mutableCopy</code> 方法返回一个新的可变对象。</li>
</ul>
<p>这种行为确保了对象的拷贝操作能够正确地维护对象的可变性属性，从而避免不必要的副本创建和内存消耗。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>copy</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS中copy与mutableCopy</title>
    <url>/2024/08/08/iOS/OC/001-OC%E5%B1%9E%E6%80%A7%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97/012-copy%E5%85%B3%E9%94%AE%E5%AD%97/copy%E4%B8%8EmutableCopy/</url>
    <content><![CDATA[<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><ul>
<li><p>杂七杂八</p>
<ul>
<li><a class="link"   href="https://blog.csdn.net/qq_18425655/article/details/51325921" >copy和mutableCopy都是浅拷贝！！！ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://www.jianshu.com/p/a99f3da35560" >iOS中的copy，mutableCopy,深拷贝和浅拷贝 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://blog.csdn.net/small_smart_jin/article/details/50804607" >关于NSString的copy和mutableCopy <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://www.jianshu.com/p/700f58eb0b86" >iOS中关键字copy与mutableCopy的详解，看我你就都懂了 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://blog.csdn.net/jslsblog/article/details/38563009" >copy和mutableCopy到底是浅拷贝还是深拷贝？ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://www.cnblogs.com/ludashi/p/3894151.html" >青玉伏案：Objective-C中的深拷贝和浅拷贝 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li><p>Stackoverflow</p>
<ul>
<li><a class="link"   href="https://stackoverflow.com/questions/9912794/deep-copy-and-shallow-copy" >Deep Copy and Shallow Copy <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://stackoverflow.com/questions/184710/what-is-the-difference-between-a-deep-copy-and-a-shallow-copy" >What is the difference between a deep copy and a shallow copy? <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li><p>Documents</p>
<ul>
<li><a class="link"   href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Collections/Articles/Copying.html#//apple_ref/doc/uid/TP40010162-SW3" >apple documentation Copy  <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="https://en.wikipedia.org/wiki/Object_copying" >维基百科 - Object copying <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
</ul>
<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul>
<li>一、copy、mutableCopy</li>
<li>二、系统的非容器类对象：这里指的是NSString、NSNumber等对象。</li>
<li>三、系统的容器类对象：指NSArray，NSSet，NSDictionary等。</li>
<li>四、另一个角度来看<ul>
<li>4.1、浅拷贝</li>
<li>4.2、单层深copy</li>
<li>4.3、双层深拷贝</li>
<li>4.4、完全深拷贝</li>
<li>4.5、自定义类对象之间的深浅拷贝问题</li>
</ul>
</li>
<li>五、@property中的copy关键字</li>
<li>六、copy和block</li>
</ul>
<h1 id="一、copy、mutableCopy"><a href="#一、copy、mutableCopy" class="headerlink" title="一、copy、mutableCopy"></a>一、copy、mutableCopy</h1><blockquote>
<ul>
<li><h5 id="copy：不可变拷贝-遵循NSCopying协议，需要对应实现copyWithZone方法；"><a href="#copy：不可变拷贝-遵循NSCopying协议，需要对应实现copyWithZone方法；" class="headerlink" title="copy：不可变拷贝,遵循NSCopying协议，需要对应实现copyWithZone方法；"></a>copy：不可变拷贝,遵循NSCopying协议，需要对应实现copyWithZone方法；</h5></li>
<li><h5 id="mutableCopy：可变拷贝，遵循NSMutableCopying协议，需要对应实现mutableCopyWithZone-方法；"><a href="#mutableCopy：可变拷贝，遵循NSMutableCopying协议，需要对应实现mutableCopyWithZone-方法；" class="headerlink" title="mutableCopy：可变拷贝，遵循NSMutableCopying协议，需要对应实现mutableCopyWithZone:方法；"></a>mutableCopy：可变拷贝，遵循NSMutableCopying协议，需要对应实现mutableCopyWithZone:方法；</h5></li>
</ul>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/08/08/iOS/OC/001-OC%E5%B1%9E%E6%80%A7%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97/012-copy%E5%85%B3%E9%94%AE%E5%AD%97/copy%E4%B8%8EmutableCopy/005.webp"
                     
                ></p>
<h1 id="二、系统的非容器类对象：这里指的是NSString、NSNumber等对象。"><a href="#二、系统的非容器类对象：这里指的是NSString、NSNumber等对象。" class="headerlink" title="二、系统的非容器类对象：这里指的是NSString、NSNumber等对象。"></a>二、系统的非容器类对象：这里指的是NSString、NSNumber等对象。</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line"> // const是常量字符串,存在常量区 </span><br><span class="line"> // constStr指针存在栈区, 指针指向常量区 </span><br><span class="line">NSString * constStr = @&quot;const&quot;;</span><br><span class="line">NSString * constStrCopy = [constStr copy];</span><br><span class="line">NSMutableString * constStrMutableCopy = [constStr mutableCopy];</span><br><span class="line">NSLog(@&quot;constStr = %p = %@&quot;,constStr,constStr);</span><br><span class="line">NSLog(@&quot;constStrCopy = %p = %@&quot;,constStrCopy,constStrCopy);</span><br><span class="line">NSLog(@&quot;constStrMutableCopy = %p = %@&quot;,constStrMutableCopy,constStrMutableCopy);</span><br><span class="line"></span><br><span class="line">// originStr在栈中,指向堆区的地址 </span><br><span class="line">NSString * originStr = [NSString stringWithFormat:@&quot;origin&quot;];</span><br><span class="line">NSString * originStrCopy = [originStr copy];</span><br><span class="line">NSMutableString * originStrMutableCopy = [originStr mutableCopy];</span><br><span class="line">NSLog(@&quot;originStr = %p = %@&quot;,originStr,originStr);</span><br><span class="line">NSLog(@&quot;originStrCopy = %p = %@&quot;,originStrCopy,originStrCopy);</span><br><span class="line">NSLog(@&quot;originStrMutableCopy = %p = %@&quot;,originStrMutableCopy,originStrMutableCopy);</span><br><span class="line">    </span><br><span class="line">NSMutableString *mutableOriginStr = [NSMutableString stringWithFormat:@&quot;mutableOrigin&quot;];</span><br><span class="line">NSMutableString *mutableOriginStrCopy = [mutableOriginStr copy];</span><br><span class="line">NSMutableString *mutableOriginStrMutableCopy = [mutableOriginStr mutableCopy];</span><br><span class="line">NSLog(@&quot;mutableOriginStr = %p = %@&quot;,mutableOriginStr,mutableOriginStr);</span><br><span class="line">NSLog(@&quot;mutableOriginStrCopy = %p = %@&quot;,mutableOriginStrCopy,mutableOriginStrCopy);</span><br><span class="line">NSLog(@&quot;mutableOriginStrMutableCopy = %p = %@&quot;,mutableOriginStrMutableCopy,mutableOriginStrMutableCopy);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 返回值测试对象是否为mutable</span><br><span class="line">[constStrMutableCopy appendString:@&quot;const&quot;];</span><br><span class="line">[originStrMutableCopy appendString:@&quot;origin&quot;];</span><br><span class="line">#pragma warnning - ERROR</span><br><span class="line">[mutableOriginStrCopy appendString:@&quot;mm&quot;];   // ERROR</span><br></pre></td></tr></table></figure></div>
<p>输出</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">constStr = 0x109a32558</span><br><span class="line">constStrCopy = 0x109a32558</span><br><span class="line">constStrMutableCopy = 0x60000307ad00</span><br><span class="line"></span><br><span class="line">originStr = 0xc117d077374719f4</span><br><span class="line">originStrCopy = 0xc117d077374719f4</span><br><span class="line">originStrMutableCopy = 0x60000307ac40</span><br><span class="line"></span><br><span class="line">mutableOriginStr = 0x60000307ac70</span><br><span class="line">mutableOriginStrCopy = 0x600003e7d960</span><br><span class="line">mutableOriginStrMutableCopy = 0x60000307adc0</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/08/08/iOS/OC/001-OC%E5%B1%9E%E6%80%A7%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97/012-copy%E5%85%B3%E9%94%AE%E5%AD%97/copy%E4%B8%8EmutableCopy/006.png"
                      alt="总结图"
                ></p>
<blockquote>
<h6 id="总结：对于系统的非容器类对象，我们可以认为，如果对不可变对象复制，copy是指针复制（浅拷贝）和mutableCopy就是对象复制（深拷贝）。如果是对可变对象复制，都是深拷贝，但是copy返回的对象是不可变的。"><a href="#总结：对于系统的非容器类对象，我们可以认为，如果对不可变对象复制，copy是指针复制（浅拷贝）和mutableCopy就是对象复制（深拷贝）。如果是对可变对象复制，都是深拷贝，但是copy返回的对象是不可变的。" class="headerlink" title="总结：对于系统的非容器类对象，我们可以认为，如果对不可变对象复制，copy是指针复制（浅拷贝）和mutableCopy就是对象复制（深拷贝）。如果是对可变对象复制，都是深拷贝，但是copy返回的对象是不可变的。"></a>总结：对于系统的非容器类对象，我们可以认为，如果对不可变对象复制，copy是指针复制（浅拷贝）和mutableCopy就是对象复制（深拷贝）。如果是对可变对象复制，都是深拷贝，但是copy返回的对象是不可变的。</h6><h6 id="copy返回的对象是不可变的，mutableCopy是可变的。"><a href="#copy返回的对象是不可变的，mutableCopy是可变的。" class="headerlink" title="copy返回的对象是不可变的，mutableCopy是可变的。"></a>copy返回的对象是不可变的，mutableCopy是可变的。</h6></blockquote>
<p><strong>NSString内存分配结论：</strong><br><a class="link"   href="https://www.aliyun.com/jiaocheng/359361.html" >iOS的关于堆区和栈区 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@&quot;&quot; 和 initWithString：方法生成的字符串分配在常量区，系统自动管理内存；</span><br><span class="line"></span><br><span class="line">initWithFormat：和 stringWithFormat: 方法生成的字符串分配在堆区，autorelease；</span><br></pre></td></tr></table></figure></div>

<h1 id="三、系统的容器类对象：指NSArray，NSSet，NSDictionary等。"><a href="#三、系统的容器类对象：指NSArray，NSSet，NSDictionary等。" class="headerlink" title="三、系统的容器类对象：指NSArray，NSSet，NSDictionary等。"></a>三、系统的容器类对象：指NSArray，NSSet，NSDictionary等。</h1><p><a class="link"   href="https://blog.csdn.net/qq_18425655/article/details/51325921" >copy和mutableCopy都是浅拷贝！！！ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://www.jianshu.com/p/ad1fb29b6070" >iOS深浅拷贝（纠错） <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/08/08/iOS/OC/001-OC%E5%B1%9E%E6%80%A7%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97/012-copy%E5%85%B3%E9%94%AE%E5%AD%97/copy%E4%B8%8EmutableCopy/007.png"
                      alt="浅拷贝与深拷贝"
                ></p>
<blockquote>
<h6 id="观点一：-所有系统容器类的copy或mutableCopy方法，都是浅拷贝！！！"><a href="#观点一：-所有系统容器类的copy或mutableCopy方法，都是浅拷贝！！！" class="headerlink" title="观点一： 所有系统容器类的copy或mutableCopy方法，都是浅拷贝！！！"></a>观点一： 所有系统容器类的copy或mutableCopy方法，都是浅拷贝！！！</h6></blockquote>
<p><strong>验证一：NSArray进行copy与mutableCopy，并改变NSArray内元素值，查看拷贝对象内部值的变化。</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSArray * arr = [NSArray arrayWithObjects:</span><br><span class="line">                 [NSMutableString stringWithString:@&quot;one&quot;],</span><br><span class="line">                 [NSMutableString stringWithString:@&quot;two&quot;],</span><br><span class="line">                 [NSMutableString stringWithString:@&quot;three&quot;],</span><br><span class="line">                 [NSMutableString stringWithString:@&quot;four&quot;],nil];</span><br><span class="line">NSArray * arrcopy = [arr copy];</span><br><span class="line">NSMutableArray * arrmutablecopy = [arr mutableCopy];</span><br><span class="line">NSLog(@&quot;arr = %p = %p&quot;,arr,arr[0]);</span><br><span class="line">NSLog(@&quot;arrcopy = %p = %p&quot;,arrcopy,arrcopy[0]);</span><br><span class="line">NSLog(@&quot;arrmutablecopy = %p = %p&quot;,arrmutablecopy,arrmutablecopy[0]);</span><br><span class="line"></span><br><span class="line">NSMutableString * mStr;</span><br><span class="line">mStr = arr[0];</span><br><span class="line">[mStr appendString:@&quot;--array&quot;];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;改变内部元素后 arr：%@ = %p&quot;,arr,arr[0]);</span><br><span class="line">NSLog(@&quot;改变内部元素后 arrcopy：%@ = %p&quot;,arrcopy,arrcopy[0]);</span><br><span class="line">NSLog(@&quot;改变内部元素后 arrmutablecopy：%@ = %p&quot;,arrmutablecopy,arrmutablecopy[0]);</span><br></pre></td></tr></table></figure></div>

<p>输出</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">arr = 0x604000446390 = 0x604000445d90</span><br><span class="line">arrcopy = 0x604000446390 = 0x604000445d90</span><br><span class="line">arrmutablecopy = 0x604000445520 = 0x604000445d90</span><br><span class="line">改变内部元素后 arr：(</span><br><span class="line">    &quot;one--array&quot;,</span><br><span class="line">    two,</span><br><span class="line">    three,</span><br><span class="line">    four</span><br><span class="line">) = 0x604000445d90</span><br><span class="line">改变内部元素后 arrcopy：(</span><br><span class="line">    &quot;one--array&quot;,</span><br><span class="line">    two,</span><br><span class="line">    three,</span><br><span class="line">    four</span><br><span class="line">) = 0x604000445d90</span><br><span class="line">改变内部元素后 arrmutablecopy：(</span><br><span class="line">    &quot;one--array&quot;,</span><br><span class="line">    two,</span><br><span class="line">    three,</span><br><span class="line">    four</span><br><span class="line">) = 0x604000445d90</span><br></pre></td></tr></table></figure></div>

<p><strong>验证二：NSMutableArray进行copy与mutableCopy，并改变NSMutableArray内元素值，查看拷贝对象内部值的变化。</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSMutableArray *mutableArr = [NSMutableArray arrayWithObjects:</span><br><span class="line">                              [NSMutableString stringWithString:@&quot;abc&quot;],</span><br><span class="line">                              [NSMutableString stringWithString:@&quot;def&quot;],</span><br><span class="line">                              [NSMutableString stringWithString:@&quot;ghi&quot;],</span><br><span class="line">                              [NSMutableString stringWithString:@&quot;jkl&quot;], nil];</span><br><span class="line">NSArray * mutableArrcopy = [mutableArr copy];</span><br><span class="line">NSMutableArray * mutableArrmutablecopy = [mutableArr mutableCopy];</span><br><span class="line">NSLog(@&quot;mutableArr = %p = %p&quot;,mutableArr,mutableArr[0]);</span><br><span class="line">NSLog(@&quot;mutableArrcopy = %p = %p&quot;,mutableArrcopy,mutableArrcopy[0]);</span><br><span class="line">NSLog(@&quot;mutableArrmutablecopy = %p = %p&quot;,mutableArrmutablecopy,mutableArrmutablecopy[0]);</span><br><span class="line"></span><br><span class="line">NSMutableString * mStr1;</span><br><span class="line">mStr1 = mutableArr[0];</span><br><span class="line">[mStr1 appendString:@&quot;--mutablearray&quot;];</span><br><span class="line"></span><br><span class="line">[mutableArrmutablecopy addObject:@&quot;FFF&quot;];</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;改变内部元素后 mutableArr：%@ = %p&quot;,mutableArr,mutableArr[0]);</span><br><span class="line">NSLog(@&quot;改变内部元素后 mutableArrcopy：%@ = %p&quot;,mutableArrcopy,mutableArrcopy[0]);</span><br><span class="line">NSLog(@&quot;改变内部元素后 mutableArrmutablecopy：%@ = %p&quot;,mutableArrmutablecopy,mutableArrmutablecopy[0]);</span><br></pre></td></tr></table></figure></div>

<p>输出</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">mutableArr = 0x604000452b10 = 0x604000452a80</span><br><span class="line">mutableArrcopy = 0x604000452b70 = 0x604000452a80</span><br><span class="line">mutableArrmutablecopy = 0x60400025fe90 = 0x604000452a80</span><br><span class="line">改变内部元素后 mutableArr：(</span><br><span class="line">    &quot;abc--mutablearray&quot;,</span><br><span class="line">    def,</span><br><span class="line">    ghi,</span><br><span class="line">    jkl</span><br><span class="line">) = 0x604000452a80</span><br><span class="line">改变内部元素后 mutableArrcopy：(</span><br><span class="line">    &quot;abc--mutablearray&quot;,</span><br><span class="line">    def,</span><br><span class="line">    ghi,</span><br><span class="line">    jkl</span><br><span class="line">) = 0x604000452a80</span><br><span class="line">改变内部元素后 mutableArrmutablecopy：(</span><br><span class="line">    &quot;abc--mutablearray&quot;,</span><br><span class="line">    def,</span><br><span class="line">    ghi,</span><br><span class="line">    jkl,</span><br><span class="line">    FFF</span><br><span class="line">) = 0x604000452a80</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/08/08/iOS/OC/001-OC%E5%B1%9E%E6%80%A7%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97/012-copy%E5%85%B3%E9%94%AE%E5%AD%97/copy%E4%B8%8EmutableCopy/006.png"
                      alt="总结图"
                ></p>
<blockquote>
<h6 id="总结：copy操作返回的必然是一个不可变对象，无论源对象是可变对象还是不可变对象。如果源对象是一个不可变对象，那么它们（源对象和新生成的对象）指向同一个对象，如果源对象是可变对象，它们指向不同对象。"><a href="#总结：copy操作返回的必然是一个不可变对象，无论源对象是可变对象还是不可变对象。如果源对象是一个不可变对象，那么它们（源对象和新生成的对象）指向同一个对象，如果源对象是可变对象，它们指向不同对象。" class="headerlink" title="总结：copy操作返回的必然是一个不可变对象，无论源对象是可变对象还是不可变对象。如果源对象是一个不可变对象，那么它们（源对象和新生成的对象）指向同一个对象，如果源对象是可变对象，它们指向不同对象。"></a>总结：copy操作返回的必然是一个不可变对象，无论源对象是可变对象还是不可变对象。如果源对象是一个不可变对象，那么它们（源对象和新生成的对象）指向同一个对象，如果源对象是可变对象，它们指向不同对象。</h6><h6 id="mutableCopy返回的必然是一个可变对象，无论源对象是可变对象还是不可变对象，它们（源对象和新生成的对象）仍指向不同地址，是两个对象。"><a href="#mutableCopy返回的必然是一个可变对象，无论源对象是可变对象还是不可变对象，它们（源对象和新生成的对象）仍指向不同地址，是两个对象。" class="headerlink" title="mutableCopy返回的必然是一个可变对象，无论源对象是可变对象还是不可变对象，它们（源对象和新生成的对象）仍指向不同地址，是两个对象。"></a>mutableCopy返回的必然是一个可变对象，无论源对象是可变对象还是不可变对象，它们（源对象和新生成的对象）仍指向不同地址，是两个对象。</h6></blockquote>
<blockquote>
<h6 id="特别注意的是：对于集合类的可变对象来说，深拷贝并非严格意义上的深复制，只能算是单层深复制，即虽然新开辟了内存地址，但是存放在内存上的值（也就是数组里的元素仍然之原数组元素值，并没有另外复制一份），这就叫做单层深复制。"><a href="#特别注意的是：对于集合类的可变对象来说，深拷贝并非严格意义上的深复制，只能算是单层深复制，即虽然新开辟了内存地址，但是存放在内存上的值（也就是数组里的元素仍然之原数组元素值，并没有另外复制一份），这就叫做单层深复制。" class="headerlink" title="特别注意的是：对于集合类的可变对象来说，深拷贝并非严格意义上的深复制，只能算是单层深复制，即虽然新开辟了内存地址，但是存放在内存上的值（也就是数组里的元素仍然之原数组元素值，并没有另外复制一份），这就叫做单层深复制。"></a>特别注意的是：对于集合类的可变对象来说，深拷贝并非严格意义上的深复制，只能算是单层深复制，即虽然新开辟了内存地址，但是存放在内存上的值（也就是数组里的元素仍然之原数组元素值，并没有另外复制一份），这就叫做单层深复制。</h6></blockquote>
<h1 id="四、另一个角度来看"><a href="#四、另一个角度来看" class="headerlink" title="四、另一个角度来看"></a>四、另一个角度来看</h1><h2 id="4-1、浅拷贝"><a href="#4-1、浅拷贝" class="headerlink" title="4.1、浅拷贝"></a>4.1、浅拷贝</h2><p><a class="link"   href="https://www.cnblogs.com/beckwang0912/p/7212075.html" >iOS 图文并茂的带你了解深拷贝与浅拷贝 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://www.jianshu.com/p/ebbac2fec4c6" >Objective-C copy，看我就够了 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSArray *arr = [NSArray arrayWithObjects:@&quot;1&quot;, nil];</span><br><span class="line">NSArray *copyArr = [arr copy];</span><br><span class="line">NSLog(@&quot;%p&quot;, arr);</span><br><span class="line">NSLog(@&quot;%p&quot;, copyArr);</span><br></pre></td></tr></table></figure></div>
<p>输出：浅拷贝</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">2018-10-24 10:00:17.256591+0800 TodayNews[2229:70407] 0x60000043d3c0</span><br><span class="line">2018-10-24 10:00:17.256705+0800 TodayNews[2229:70407] 0x60000043d3c0</span><br></pre></td></tr></table></figure></div>

<h2 id="4-2、单层深copy"><a href="#4-2、单层深copy" class="headerlink" title="4.2、单层深copy"></a>4.2、单层深copy</h2><p><strong>这里的单层指的是完成了NSArray对象的深copy，而未对其容器内对象进行处理。</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSArray *arr = [NSArray arrayWithObjects:@&quot;1&quot;, nil];</span><br><span class="line">NSArray *copyArr = [arr mutableCopy];</span><br><span class="line">    </span><br><span class="line">NSLog(@&quot;%p&quot;, arr);</span><br><span class="line">NSLog(@&quot;%p&quot;, copyArr);</span><br><span class="line">    </span><br><span class="line">// 打印arr、copyArr内部元素进行对比</span><br><span class="line">NSLog(@&quot;%p&quot;, arr[0]);</span><br><span class="line">NSLog(@&quot;%p&quot;, copyArr[0]);</span><br></pre></td></tr></table></figure></div>
<p>输出：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">2018-10-24 10:06:10.985032+0800 TodayNews[2330:73697] 0x60000043a200</span><br><span class="line">2018-10-24 10:06:10.985224+0800 TodayNews[2330:73697] 0x600000642a60</span><br><span class="line">2018-10-24 10:06:10.985347+0800 TodayNews[2330:73697] 0x102bf00d8</span><br><span class="line">2018-10-24 10:06:10.985438+0800 TodayNews[2330:73697] 0x102bf00d8</span><br></pre></td></tr></table></figure></div>

<h2 id="4-3、双层深拷贝"><a href="#4-3、双层深拷贝" class="headerlink" title="4.3、双层深拷贝"></a>4.3、双层深拷贝</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 随意创建一个NSMutableString对象</span><br><span class="line">NSMutableString *mutableString = [NSMutableString stringWithString:@&quot;1&quot;];</span><br><span class="line">// 随意创建一个包涵NSMutableString的NSMutableArray对象</span><br><span class="line">NSMutableString *mutalbeString1 = [NSMutableString stringWithString:@&quot;1&quot;];</span><br><span class="line">NSMutableArray *mutableArr = [NSMutableArray arrayWithObjects:mutalbeString1, nil];</span><br><span class="line">// 将mutableString和mutableArr放入一个新的NSArray中</span><br><span class="line">NSArray *testArr = [NSArray arrayWithObjects:mutableString, mutableArr, nil];</span><br><span class="line">// 通过官方文档提供的方式创建copy</span><br><span class="line">NSArray *testArrCopy = [[NSArray alloc] initWithArray:testArr copyItems:YES];</span><br><span class="line"></span><br><span class="line">// testArr和testArrCopy指针对比</span><br><span class="line">NSLog(@&quot;%p&quot;, testArr);</span><br><span class="line">NSLog(@&quot;%p&quot;, testArrCopy);</span><br><span class="line"></span><br><span class="line">// testArr和testArrCopy中元素指针对比</span><br><span class="line">// mutableString对比</span><br><span class="line">NSLog(@&quot;%p&quot;, testArr[0]);</span><br><span class="line">NSLog(@&quot;%p&quot;, testArrCopy[0]);</span><br><span class="line">// mutableArr对比</span><br><span class="line">NSLog(@&quot;%p&quot;, testArr[1]);</span><br><span class="line">NSLog(@&quot;%p&quot;, testArrCopy[1]);</span><br><span class="line"></span><br><span class="line">// mutableArr中的元素对比，即mutalbeString1对比</span><br><span class="line">NSLog(@&quot;%p&quot;, testArr[1][0]);</span><br><span class="line">NSLog(@&quot;%p&quot;, testArrCopy[1][0]);</span><br></pre></td></tr></table></figure></div>
<p>输出</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">2018-10-24 10:10:20.994041+0800 TodayNews[2442:76854] 0x600000426500</span><br><span class="line">2018-10-24 10:10:20.994165+0800 TodayNews[2442:76854] 0x6000004264c0</span><br><span class="line">2018-10-24 10:10:20.994280+0800 TodayNews[2442:76854] 0x600000652870</span><br><span class="line">2018-10-24 10:10:20.994421+0800 TodayNews[2442:76854] 0xa000000000000311</span><br><span class="line">2018-10-24 10:10:20.994512+0800 TodayNews[2442:76854] 0x600000652960</span><br><span class="line">2018-10-24 10:10:20.994599+0800 TodayNews[2442:76854] 0x600000005ef0</span><br><span class="line">2018-10-24 10:10:20.994701+0800 TodayNews[2442:76854] 0x6000006528a0</span><br><span class="line">2018-10-24 10:10:20.994993+0800 TodayNews[2442:76854] 0x6000006528a0</span><br></pre></td></tr></table></figure></div>

<h2 id="4-4、完全深拷贝"><a href="#4-4、完全深拷贝" class="headerlink" title="4.4、完全深拷贝"></a>4.4、完全深拷贝</h2><p>方式一：<strong>如果想完美的解决NSArray嵌套NSArray这种情形，可以使用归档、解档的方式。</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 随意创建一个NSMutableString对象</span><br><span class="line">NSMutableString *mutableString = [NSMutableString stringWithString:@&quot;1&quot;];</span><br><span class="line">// 随意创建一个包涵NSMutableString的NSMutableArray对象</span><br><span class="line">NSMutableString *mutalbeString1 = [NSMutableString stringWithString:@&quot;1&quot;];</span><br><span class="line">NSMutableArray *mutableArr = [NSMutableArray arrayWithObjects:mutalbeString1, nil];</span><br><span class="line">// 将mutableString和mutableArr放入一个新的NSArray中</span><br><span class="line">NSArray *testArr = [NSArray arrayWithObjects:mutableString, mutableArr, nil];</span><br><span class="line">// 通过归档、解档方式创建copy</span><br><span class="line">NSArray *testArrCopy = [NSKeyedUnarchiver unarchiveObjectWithData:</span><br><span class="line">                            [NSKeyedArchiver archivedDataWithRootObject:testArr]];;</span><br><span class="line">    </span><br><span class="line">// testArr和testArrCopy指针对比</span><br><span class="line">NSLog(@&quot;%p&quot;, testArr);</span><br><span class="line">NSLog(@&quot;%p&quot;, testArrCopy);</span><br><span class="line">    </span><br><span class="line">// testArr和testArrCopy中元素指针对比</span><br><span class="line">// mutableString对比</span><br><span class="line">NSLog(@&quot;%p&quot;, testArr[0]);</span><br><span class="line">NSLog(@&quot;%p&quot;, testArrCopy[0]);</span><br><span class="line">// mutableArr对比</span><br><span class="line">NSLog(@&quot;%p&quot;, testArr[1]);</span><br><span class="line">NSLog(@&quot;%p&quot;, testArrCopy[1]);</span><br><span class="line">    </span><br><span class="line">// mutableArr中的元素对比，即mutalbeString1对比</span><br><span class="line">NSLog(@&quot;%p&quot;, testArr[1][0]);</span><br><span class="line">NSLog(@&quot;%p&quot;, testArrCopy[1][0]);</span><br></pre></td></tr></table></figure></div>
<p>输出</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">2018-10-24 10:15:11.448311+0800 TodayNews[2549:80583] 0x600000430640</span><br><span class="line">2018-10-24 10:15:11.448435+0800 TodayNews[2549:80583] 0x6000004309e0</span><br><span class="line">2018-10-24 10:15:11.448528+0800 TodayNews[2549:80583] 0x60000045e2a0</span><br><span class="line">2018-10-24 10:15:11.448684+0800 TodayNews[2549:80583] 0x60000045e3c0</span><br><span class="line">2018-10-24 10:15:11.448773+0800 TodayNews[2549:80583] 0x60000045d0d0</span><br><span class="line">2018-10-24 10:15:11.448925+0800 TodayNews[2549:80583] 0x60000045e450</span><br><span class="line">2018-10-24 10:15:11.449012+0800 TodayNews[2549:80583] 0x60000045e1b0</span><br><span class="line">2018-10-24 10:15:11.449161+0800 TodayNews[2549:80583] 0x60000045e7e0</span><br></pre></td></tr></table></figure></div>

<p><strong>方式二：<code>- (instancetype)initWithArray:(NSArray&lt;ObjectType&gt; *)array copyItems:(BOOL)flag</code>;</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSMutableArray *marry1 = [[NSMutableArray alloc] init];</span><br><span class="line">    </span><br><span class="line">NSMutableString *mstr1 = [[NSMutableString alloc]initWithString:@&quot;value1&quot;];</span><br><span class="line">NSMutableString *mstr2 = [[NSMutableString alloc]initWithString:@&quot;value2&quot;];</span><br><span class="line">    </span><br><span class="line">[marry1 addObject:mstr1];</span><br><span class="line">[marry1 addObject:mstr2];</span><br><span class="line">    </span><br><span class="line">NSArray *marray2 = [[NSArray alloc] initWithArray:marry1 copyItems:YES];</span><br><span class="line">    </span><br><span class="line">NSLog(@&quot;marry1:%p - %@ \r\n&quot;,marry1,marry1);</span><br><span class="line">NSLog(@&quot;marry2:%p - %@ \r\n&quot;,marray2,marray2);</span><br><span class="line">NSLog(@&quot;数组元素地址:value1:%p - value2:%p \r\n&quot;,marry1[0],marry1[1]);</span><br><span class="line">NSLog(@&quot;数组元素地址:value1:%p - value2:%p \r\n&quot;,marray2[0],marray2[1]);</span><br></pre></td></tr></table></figure></div>

<h2 id="4-5、自定义类对象之间的深浅拷贝问题"><a href="#4-5、自定义类对象之间的深浅拷贝问题" class="headerlink" title="4.5、自定义类对象之间的深浅拷贝问题"></a>4.5、自定义类对象之间的深浅拷贝问题</h2><p>在Objective-C中并不是所有的类都支持拷贝；只有遵循NSCopying协议的类，才支持copy拷贝，只有遵循NSMutableCopying协议的类，才支持mutableCopy拷贝。如果没有遵循拷贝协议，拷贝时会出错。</p>
<p>如果我们想再我们自定义的类中支持copy和mutableCopy那么我们就需要使我们定义的类遵循NSCopying和NSMutableCopying协议，代码如下：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@interface Study_CustomObject_copy_mutableCopy : NSObject &lt;NSCopying, NSMutableCopying&gt;  // 协议</span><br><span class="line">@property (copy,nonatomic) NSString *name;</span><br><span class="line">@property (copy,nonatomic) NSString *age;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation Study_CustomObject_copy_mutableCopy</span><br><span class="line">- (id)copyWithZone:(NSZone *)zone</span><br><span class="line">&#123;</span><br><span class="line">    Study_CustomObject_copy_mutableCopy *customobject = [[Study_CustomObject_copy_mutableCopy allocWithZone:zone] init];</span><br><span class="line">    customobject.age = self.age;</span><br><span class="line">    customobject.name = self.name;</span><br><span class="line">    return customobject;</span><br><span class="line">&#125;</span><br><span class="line">- (id)mutableCopyWithZone:(NSZone *)zone &#123;</span><br><span class="line">    Study_CustomObject_copy_mutableCopy *customobject = [[Study_CustomObject_copy_mutableCopy allocWithZone:zone] init];</span><br><span class="line">    customobject.age = self.age;</span><br><span class="line">    customobject.name = self.name;</span><br><span class="line">    return customobject;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div>


<p><strong>调用 、 输出</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 调用</span><br><span class="line">&#123;</span><br><span class="line">    Study_CustomObject_copy_mutableCopy *object = [[Study_CustomObject_copy_mutableCopy alloc]init];</span><br><span class="line">    object.age = @&quot;99&quot;;</span><br><span class="line">    object.name = @&quot;lionsom&quot;;</span><br><span class="line">    </span><br><span class="line">    Study_CustomObject_copy_mutableCopy *objectCopy = [object copy];</span><br><span class="line">    Study_CustomObject_copy_mutableCopy *objectMutableCopy = [object mutableCopy];</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;object === %p , name === %p , age === %p&quot;,object, object.name, object.age);</span><br><span class="line">    NSLog(@&quot;objectCopy === %p , name === %p , age === %p&quot;,objectCopy, objectCopy.name, objectCopy.age);</span><br><span class="line">    NSLog(@&quot;objectMutableCopy === %p , name === %p , age === %p&quot;,objectMutableCopy, objectMutableCopy.name, objectMutableCopy.age);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">object === 0x60400023d7a0 , name === 0x100744ed8 , age === 0x100744eb8</span><br><span class="line">objectCopy === 0x60400023bd80 , name === 0x100744ed8 , age === 0x100744eb8</span><br><span class="line">objectMutableCopy === 0x60400023d180 , name === 0x100744ed8 , age === 0x100744eb8</span><br></pre></td></tr></table></figure></div>


<h1 id="五、-property中的copy关键字"><a href="#五、-property中的copy关键字" class="headerlink" title="五、@property中的copy关键字"></a>五、@property中的copy关键字</h1><p><a class="link"   href="https://blog.csdn.net/winzlee/article/details/51752354" >iOS内存管理（6）–NSArray与NSMutableArray用copy修饰还是strong <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://blog.csdn.net/G_eorge/article/details/78219957?locationNum=9&fps=1" >OC的深拷贝与浅拷贝–NSArray与NSMutableArray应该使用copy还是strong？ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<ul>
<li><h5 id="NSString"><a href="#NSString" class="headerlink" title="NSString"></a>NSString</h5><ul>
<li>strong 关键词：两个string指向相同的内存地址，修改一个，另一个也会改变；</li>
<li>(<strong>推荐</strong>)copy 关键词：两个string指向不同的内存地址，互不影响；</li>
</ul>
</li>
<li><h5 id="NSMutableString"><a href="#NSMutableString" class="headerlink" title="NSMutableString"></a>NSMutableString</h5><ul>
<li>(<strong>推荐</strong>)strong 关键词：两个string指向相同的内存地址，修改一个，另一个也会改变；</li>
<li>(<strong>崩溃</strong>)copy 关键词：copy之后，就把变量string变成了不可变的NSString类型，对不可变的NSString使用了NSMutableString的方法appendString。</li>
</ul>
</li>
<li><h5 id="NSArray"><a href="#NSArray" class="headerlink" title="NSArray"></a>NSArray</h5><ul>
<li>strong 关键词：两个string指向相同的内存地址，修改一个，另一个也会改变；</li>
<li>(<strong>推荐</strong>)copy 关键词：此时内存地址都是不同的，修改一个，互不影响；</li>
</ul>
</li>
<li><h5 id="NSMutableArray"><a href="#NSMutableArray" class="headerlink" title="NSMutableArray"></a>NSMutableArray</h5><ul>
<li>(<strong>推荐</strong>)strong 关键词：两个string指向相同的内存地址，修改一个，另一个也会改变；</li>
<li>(<strong>崩溃</strong>)copy 关键词：copy之后，就把变量array变成了不可变的NSArray类型，对不可变的NSArray使用了NSMutableArray的方法addObject。</li>
</ul>
</li>
</ul>
<blockquote>
<p>当修饰可变类型的属性时，如NSMutableArray、NSMutableDictionary、NSMutableString，用strong。</p>
<p>当修饰不可变类型的属性时，如NSArray、NSDictionary、NSString，用copy。</p>
</blockquote>
<h1 id="六、copy和block"><a href="#六、copy和block" class="headerlink" title="六、copy和block"></a>六、copy和block</h1><p><a class="link"   href="https://blog.csdn.net/leonliu070602/article/details/52981884" >block使用copy原理 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>简单来说，block就像一个函数指针，指向我们要使用的函数。</p>
<p>就和函数调用一样的，不管你在哪里写了这个block，只要你把它放在了内存中（通过调用存在这个block的方法或者是函数），不管放在栈中还是在堆中，还是在静态区。只要他没有被销毁，你都可以通过你声明的block调用他。</p>
<p>说到在类中声明一个block为什么要用copy修饰的话，那就要先说block的三种类型。</p>
<p>1._NSConcreteGlobalBlock,全局的静态block，不会访问外部的变量。就是说如果你的block没有调用其他的外部变量，那你的block类型就是这种。例如：你仅仅在你的block里面写一个NSLog(“hello world”);</p>
<p>2._NSConcreteStackBlock 保存在栈中的 block，当函数返回时会被销毁。这个block就是你声明的时候不用c opy修饰，并且你的block访问了外部变量。</p>
<p>3._NSConcreteMallocBlock 保存在堆中的 block，当引用计数为 0 时会被销毁。好了，这个就是今天的主角 ，用copy修饰的block。</p>
<p>我们知道，函数的声明周期是随着函数调用的结束就终止了。我们的block是写在函数中的。</p>
<p>如果是全局静态block的话，他直到程序结束的时候，才会被被释放。但是我们实际操作中基本上不会使用到不访问外部变量的block。【但是在测试三种区别的时候，因为没有很好的理解这种block，（用没有copy修饰和没有访问外部变量的block）试了好多次，以为是放在静态区里面的block没有随函数结束被释放。这是个小坑】</p>
<p>如果是保存在栈中的block，他会随着函数调用结束被销毁。从而导致我们在执行一个包含block的函数之后，就无法再访问这个block。因为（函数结束，函数栈就销毁了，存在函数里面的block也就没有了），我们再使用block时，就会产生空指针异常。</p>
<p>如果是堆中的block，也就是copy修饰的block。他的生命 周期就是随着对象的销毁而结束的。只要对象不销毁，我们就可以调用的到在堆中的block。</p>
<p>这就是为什么我们要用copy来修饰block。因为不用copy修饰的访问外部变量的block，只在他所在的函数被调用的那一瞬间可以使用。之后就消失了。</p>
]]></content>
      <categories>
        <category>移动端iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>copy</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 中的属性变量、成员变量、实例变量</title>
    <url>/2024/07/22/iOS/OC/001-OC%E5%B1%9E%E6%80%A7%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97/013-iOS%E4%B8%AD%E7%9A%84%E5%B1%9E%E6%80%A7%E5%8F%98%E9%87%8F%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E3%80%81%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F/README/</url>
    <content><![CDATA[<!-- # iOS 中的属性变量、成员变量、实例变量 -->

<p>在 iOS 开发中，属性变量、成员变量和实例变量是指向对象数据的不同方式，了解它们之间的区别和使用场景非常重要。</p>
<span id="more"></span>

<h3 id="属性变量（Property）"><a href="#属性变量（Property）" class="headerlink" title="属性变量（Property）"></a>属性变量（Property）</h3><p>属性变量是通过 <code>@property</code> 关键字定义的，它提供了一种面向对象的方式来访问和修改对象的内部数据。属性变量通常与 getter 和 setter 方法相关联，可以通过点语法进行访问。属性变量可以是原子性的，也可以是非原子性的，可以指定各种属性修饰符（如 <code>nonatomic</code>、<code>strong</code>、<code>weak</code> 等）。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><div class="highlight-container" data-rel="Objc"><figure class="iseeu highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></div>

<p>在使用时，可以通过点语法来访问和修改属性变量：</p>
<div class="highlight-container" data-rel="Objc"><figure class="iseeu highlight objc"><table><tr><td class="code"><pre><span class="line">MyClass *obj = [[MyClass alloc] init];</span><br><span class="line">obj.name = <span class="string">@&quot;John&quot;</span>; <span class="comment">// 调用 setter 方法</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, obj.name); <span class="comment">// 调用 getter 方法</span></span><br></pre></td></tr></table></figure></div>

<h3 id="成员变量（Member-Variable）"><a href="#成员变量（Member-Variable）" class="headerlink" title="成员变量（Member Variable）"></a>成员变量（Member Variable）</h3><p>成员变量通常是指在类的接口或实现中直接声明的变量。成员变量的访问控制依赖于变量的声明位置。如果在接口中声明，它们通常是公有的；如果在实现中声明，它们通常是私有的。成员变量直接存储在对象实例中。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><div class="highlight-container" data-rel="Objc"><figure class="iseeu highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></div>

<p>在使用时，成员变量通常通过直接访问来操作：</p>
<div class="highlight-container" data-rel="Objc"><figure class="iseeu highlight objc"><table><tr><td class="code"><pre><span class="line">MyClass *obj = [[MyClass alloc] init];</span><br><span class="line">obj-&gt;_name = <span class="string">@&quot;John&quot;</span>; <span class="comment">// 直接访问成员变量</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, obj-&gt;_name);</span><br></pre></td></tr></table></figure></div>

<h3 id="实例变量（Instance-Variable）"><a href="#实例变量（Instance-Variable）" class="headerlink" title="实例变量（Instance Variable）"></a>实例变量（Instance Variable）</h3><p>实例变量是对象实例中的变量，它们可以在类的实现部分定义，通常与 <code>@property</code> 一起使用。实例变量的作用域在类的内部，不能直接通过点语法访问。实例变量可以通过 <code>@synthesize</code> 和 <code>@dynamic</code> 关键字来管理。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><div class="highlight-container" data-rel="Objc"><figure class="iseeu highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *_privateName; <span class="comment">// 实例变量</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@synthesize</span> name = _name;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="variable language_">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</span><br><span class="line">        _privateName = <span class="string">@&quot;Private Name&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></div>

<p>在使用时，实例变量通常在类的内部方法中直接访问：</p>
<div class="highlight-container" data-rel="Objc"><figure class="iseeu highlight objc"><table><tr><td class="code"><pre><span class="line">MyClass *obj = [[MyClass alloc] init];</span><br><span class="line">obj.name = <span class="string">@&quot;John&quot;</span>; <span class="comment">// 通过属性访问</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, obj.name); <span class="comment">// 通过属性访问</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例变量 _privateName 只能在类的实现部分访问</span></span><br></pre></td></tr></table></figure></div>

<h3 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h3><ol>
<li><p><strong>属性变量（Property）</strong>：通过 <code>@property</code> 关键字声明，可以指定各种修饰符，提供 getter 和 setter 方法，通过点语法访问。通常用于定义公共接口。</p>
</li>
<li><p><strong>成员变量（Member Variable）</strong>：直接在类的接口或实现中声明，直接访问和修改。通常用于私有或受保护的数据。</p>
</li>
<li><p><strong>实例变量（Instance Variable）</strong>：在类的实现部分定义，作用域在类的内部，通常与属性变量关联，通过 <code>@synthesize</code> 和 <code>@dynamic</code> 管理。</p>
</li>
</ol>
<h3 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h3><ul>
<li><strong>属性变量</strong>：优先使用 <code>@property</code> 来定义属性，因为它提供了更高层次的封装和便利的点语法访问。</li>
<li><strong>成员变量</strong>：避免直接在接口中声明成员变量，尽量在实现部分使用实例变量来保护数据。</li>
<li><strong>实例变量</strong>：在类的内部方法中使用实例变量，以实现细粒度的数据控制和封装。</li>
</ul>
<p>通过理解和正确使用这些变量类型，可以更好地管理对象的数据和行为，提高代码的可读性和维护性。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>属性变量</tag>
        <tag>成员变量</tag>
        <tag>实例变量</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS中@public、@protected、@private、@package怎么用？</title>
    <url>/2024/07/22/iOS/OC/001-OC%E5%B1%9E%E6%80%A7%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97/014-OC%E4%B8%AD%EF%BC%8C@public%E3%80%81@protected%E3%80%81@private%E5%92%8C@package%E7%9A%84%E4%BD%BF%E7%94%A8/README/</url>
    <content><![CDATA[<!-- # ios 中@public，@protected，@private，@package 怎么用 -->

<p>在 Objective-C 中，<code>@public</code>、<code>@protected</code>、<code>@private</code> 和 <code>@package</code> 是用来定义类成员变量（instance variables）的访问权限的关键字。它们用于控制类成员变量的可见性和访问权限。这些关键字在类的接口部分或实现部分的 <code>&#123;&#125;</code> 中使用。下面是它们的用法和区别。</p>
<span id="more"></span>

<h3 id="public"><a href="#public" class="headerlink" title="@public"></a><code>@public</code></h3><p><code>@public</code> 关键字使成员变量在类的外部可见和可访问。任何对象都可以直接访问 <code>@public</code> 成员变量。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><div class="highlight-container" data-rel="Objc"><figure class="iseeu highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@public</span></span><br><span class="line">    <span class="built_in">NSString</span> *publicString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">MyClass *obj = [[MyClass alloc] init];</span><br><span class="line">obj-&gt;publicString = <span class="string">@&quot;Public String&quot;</span>; <span class="comment">// 直接访问 public 成员变量</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, obj-&gt;publicString);</span><br></pre></td></tr></table></figure></div>

<h3 id="protected"><a href="#protected" class="headerlink" title="@protected"></a><code>@protected</code></h3><p><code>@protected</code> 是默认的访问权限。<code>@protected</code> 成员变量只能在类的内部或子类中访问，但不能在类的外部访问。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><div class="highlight-container" data-rel="Objc"><figure class="iseeu highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@protected</span></span><br><span class="line">    <span class="built_in">NSString</span> *protectedString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SubClass</span> : <span class="title">MyClass</span></span></span><br><span class="line">- (<span class="type">void</span>)accessProtectedString;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SubClass</span></span></span><br><span class="line">- (<span class="type">void</span>)accessProtectedString &#123;</span><br><span class="line">    <span class="keyword">self</span>-&gt;protectedString = <span class="string">@&quot;Protected String&quot;</span>; <span class="comment">// 子类可以访问 protected 成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">MyClass *obj = [[MyClass alloc] init];</span><br><span class="line"><span class="comment">// obj-&gt;protectedString = @&quot;Protected String&quot;; // 编译错误，类的外部不能访问 protected 成员变量</span></span><br></pre></td></tr></table></figure></div>

<h3 id="private"><a href="#private" class="headerlink" title="@private"></a><code>@private</code></h3><p><code>@private</code> 成员变量只能在定义它们的类的内部访问，子类和外部类都不能访问。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><div class="highlight-container" data-rel="Objc"><figure class="iseeu highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@private</span></span><br><span class="line">    <span class="built_in">NSString</span> *privateString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line">- (<span class="type">void</span>)accessPrivateString &#123;</span><br><span class="line">    <span class="keyword">self</span>-&gt;privateString = <span class="string">@&quot;Private String&quot;</span>; <span class="comment">// 类的内部可以访问 private 成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SubClass</span> : <span class="title">MyClass</span></span></span><br><span class="line">- (<span class="type">void</span>)accessPrivateString;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SubClass</span></span></span><br><span class="line">- (<span class="type">void</span>)accessPrivateString &#123;</span><br><span class="line">    <span class="comment">// self-&gt;privateString = @&quot;Private String&quot;; // 编译错误，子类不能访问 private 成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">MyClass *obj = [[MyClass alloc] init];</span><br><span class="line"><span class="comment">// obj-&gt;privateString = @&quot;Private String&quot;; // 编译错误，类的外部不能访问 private 成员变量</span></span><br></pre></td></tr></table></figure></div>

<h3 id="package"><a href="#package" class="headerlink" title="@package"></a><code>@package</code></h3><p><code>@package</code> 成员变量的访问权限类似于 <code>@protected</code>，但是在同一个包（framework）中的所有类都可以访问这些成员变量。这在开发大型应用或框架时非常有用。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><div class="highlight-container" data-rel="Objc"><figure class="iseeu highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">@package</span></span><br><span class="line">    <span class="built_in">NSString</span> *packageString;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设此类在同一个包中</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AnotherClass</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="type">void</span>)accessPackageString:(MyClass *)obj;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AnotherClass</span></span></span><br><span class="line">- (<span class="type">void</span>)accessPackageString:(MyClass *)obj &#123;</span><br><span class="line">    obj-&gt;packageString = <span class="string">@&quot;Package String&quot;</span>; <span class="comment">// 同一个包中的类可以访问 package 成员变量</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">MyClass *obj = [[MyClass alloc] init];</span><br><span class="line"><span class="comment">// obj-&gt;packageString = @&quot;Package String&quot;; // 编译错误，不在同一个包中的类不能访问 package 成员变量</span></span><br></pre></td></tr></table></figure></div>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>**<code>@public</code>**：任何地方都可以访问。</li>
<li>**<code>@protected</code>**：只有类的内部和子类可以访问。</li>
<li>**<code>@private</code>**：只有类的内部可以访问。</li>
<li>**<code>@package</code>**：同一个包（framework）中的类可以访问。</li>
</ul>
<p>这些关键字帮助开发者更好地控制类成员变量的访问权限，确保数据的封装和安全性。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>访问权限</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS中为什么block要用copy修饰？</title>
    <url>/2024/08/08/iOS/OC/001-OC%E5%B1%9E%E6%80%A7%E3%80%81%E5%85%B3%E9%94%AE%E5%AD%97/015-%E4%B8%BA%E4%BB%80%E4%B9%88block%E8%A6%81%E7%94%A8copy%E4%BF%AE%E9%A5%B0%EF%BC%9F/index/</url>
    <content><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a class="link"   href="https://coderlawrence.github.io/2020/03/03/block%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8copy/" >block为什么要用copy来修饰
 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<h1 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h1><p>在 iOS 开发中，<code>block</code>（也称为闭包或匿名函数）通常用 <code>copy</code> 修饰符进行声明，这是为了确保 <code>block</code> 被正确管理和存储。以下是详细的原因：</p>
<h3 id="1-堆内存管理"><a href="#1-堆内存管理" class="headerlink" title="1. 堆内存管理"></a>1. <strong>堆内存管理</strong></h3><p>在 Objective-C 中，<code>block</code> 最初创建时可能是在栈（stack）上分配的，这意味着它的生命周期与它的作用域相同。当栈上的 <code>block</code> 超出其作用域时，它将被销毁。如果我们希望在栈外使用该 <code>block</code>（例如，存储在属性中或者异步调用），我们需要将其复制到堆（heap）上。</p>
<p><code>copy</code> 修饰符会将栈上的 <code>block</code> 复制到堆上，这样可以确保它在需要时仍然存在，不会因为超出作用域而被销毁。</p>
<h3 id="2-ARC-管理"><a href="#2-ARC-管理" class="headerlink" title="2. ARC 管理"></a>2. <strong>ARC 管理</strong></h3><p>在自动引用计数（ARC）环境下，<code>copy</code> 修饰符还帮助 ARC 正确管理 <code>block</code> 的生命周期。ARC 通过 <code>copy</code> 操作确保 <code>block</code> 在堆上有适当的引用计数，避免内存泄漏或访问已释放的内存。</p>
<h3 id="3-Block-的存储位置"><a href="#3-Block-的存储位置" class="headerlink" title="3. Block 的存储位置"></a>3. <strong>Block 的存储位置</strong></h3><p>根据 <code>block</code> 的存储位置，它们分为三种类型：</p>
<ul>
<li><strong>栈上的 block</strong>：默认情况下，<code>block</code> 在定义时分配在栈上。这些 <code>block</code> 的生命周期仅限于其作用域。</li>
<li><strong>堆上的 block</strong>：使用 <code>copy</code> 操作将栈上的 <code>block</code> 复制到堆上，使其生命周期延长。</li>
<li><strong>全局 block</strong>：如果 <code>block</code> 不捕获任何变量，它会被自动分配在全局数据区，无需 <code>copy</code> 操作。</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下是一个示例，说明为什么需要使用 <code>copy</code> 修饰符：</p>
<div class="highlight-container" data-rel="Objc"><figure class="iseeu highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="string">&lt;Foundation/Foundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">void</span> (^MyBlock)(<span class="type">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) MyBlock myBlock;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        MyClass *myObject = [[MyClass alloc] init];</span><br><span class="line">        <span class="type">int</span> someVar = <span class="number">42</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 定义一个 block，捕获 someVar 变量</span></span><br><span class="line">        myObject.myBlock = ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Captured variable: %d&quot;</span>, someVar);</span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在稍后时间调用 block</span></span><br><span class="line">        myObject.myBlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在上述代码中，如果我们将 <code>myBlock</code> 属性定义为 <code>strong</code> 或 <code>assign</code> 而不是 <code>copy</code>，则该 <code>block</code> 可能仍然在栈上，当超出作用域时，它将被销毁，从而导致潜在的崩溃或未定义行为。通过将其定义为 <code>copy</code>，我们确保 <code>block</code> 被正确地复制到堆上，延长其生命周期并保证其安全性。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>使用 <code>copy</code> 修饰符确保 <code>block</code> 在堆上存储，以管理其生命周期，避免内存管理问题，并确保在合适的时机正确使用 <code>block</code>。这是 iOS 开发中确保 <code>block</code> 正确工作和避免潜在问题的重要实践。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>block</tag>
      </tags>
  </entry>
  <entry>
    <title>简述OC内存管理</title>
    <url>/2024/07/22/iOS/OC/002-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/001-%E7%AE%80%E8%BF%B0OC%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/README/</url>
    <content><![CDATA[<!-- # 简述OC内存管理 -->

<p>OC（Objective-C）内存管理主要有两种方式：手动引用计数（Manual Reference Counting，MRC）和自动引用计数（Automatic Reference Counting，ARC）。以下是对这两种内存管理方式的简要介绍：</p>
 <span id="more"></span>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/22/iOS/OC/002-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/001-%E7%AE%80%E8%BF%B0OC%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/README/duck.jpeg"
                     
                ></p>
<h2 id="1-手动引用计数-MRC"><a href="#1-手动引用计数-MRC" class="headerlink" title="1. 手动引用计数 (MRC)"></a>1. 手动引用计数 (MRC)</h2><p>在MRC中，开发者需要手动管理对象的内存，通过对对象的引用计数（Reference Counting）来控制其生命周期。主要使用的内存管理方法有：</p>
<ul>
<li><strong>alloc</strong>：分配内存并初始化对象，引用计数设为1。</li>
<li><strong>retain</strong>：增加对象的引用计数。</li>
<li><strong>release</strong>：减少对象的引用计数，当引用计数为0时，释放对象的内存。</li>
<li><strong>autorelease</strong>：将对象添加到自动释放池中，当自动释放池被清空时，调用release方法。</li>
</ul>
<p>在MRC中，开发者需要小心处理内存的分配和释放，以避免内存泄漏和野指针等问题。</p>
<h2 id="2-自动引用计数-ARC"><a href="#2-自动引用计数-ARC" class="headerlink" title="2. 自动引用计数 (ARC)"></a>2. 自动引用计数 (ARC)</h2><p>ARC是苹果在iOS 5及Mac OS X Lion中引入的一种内存管理机制。它通过编译器自动插入retain、release和autorelease等方法调用，从而简化内存管理。ARC极大地减少了手动管理内存的负担，降低了内存泄漏和野指针的风险。开发者在使用ARC时，只需关注对象的生命周期，而无需手动调用内存管理方法。</p>
<p>在ARC中，有一些关键规则和概念：</p>
<ul>
<li><strong>strong</strong>：默认属性修饰符，表示对对象的强引用。</li>
<li><strong>weak</strong>：表示对对象的弱引用，不增加对象的引用计数，当对象被释放时，weak引用会自动设置为nil。</li>
<li><strong>unsafe_unretained</strong>：类似weak，但在对象被释放时不会自动设置为nil，容易导致野指针问题。</li>
<li><strong>__autoreleasing</strong>：用于临时对象的自动释放。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>OC内存管理主要通过引用计数机制来控制对象的生命周期。在MRC中，开发者需要手动管理引用计数，而在ARC中，编译器自动插入内存管理代码，极大简化了内存管理的复杂性。ARC是现代Objective-C开发中推荐的内存管理方式。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>OC</tag>
        <tag>内存管理</tag>
      </tags>
  </entry>
  <entry>
    <title>autorelease和Autorelease Pool</title>
    <url>/2024/07/22/iOS/OC/002-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/006-autorelease%E5%92%8CAutorelease%20Pool/README/</url>
    <content><![CDATA[<!-- # autorelease和Autorelease Pool -->

<p>在 iOS 和 macOS 开发中，<code>autorelease</code> 是一种内存管理机制，属于 Cocoa 的内存管理系统的一部分。<code>autorelease</code> 通过自动释放池（autorelease pool）管理对象的生命周期，帮助开发者在不需要手动调用 <code>release</code> 的情况下处理对象的释放。以下是对 <code>autorelease</code> 的详细介绍：</p>
<span id="more"></span>

<h3 id="什么是-autorelease"><a href="#什么是-autorelease" class="headerlink" title="什么是 autorelease"></a>什么是 <code>autorelease</code></h3><p><code>autorelease</code> 是一种延迟释放对象的方法。当你对一个对象调用 <code>autorelease</code> 方法时，对象不会立即被释放，而是被添加到当前的自动释放池中。当自动释放池被销毁时，池中的所有对象都会接收到一个 <code>release</code> 消息。</p>
<h3 id="自动释放池（Autorelease-Pool）"><a href="#自动释放池（Autorelease-Pool）" class="headerlink" title="自动释放池（Autorelease Pool）"></a>自动释放池（Autorelease Pool）</h3><p>自动释放池是一个临时的存储区，用于存储被标记为 <code>autorelease</code> 的对象。自动释放池的生命周期通常与运行循环（run loop）的生命周期相对应。在每次运行循环迭代结束时，自动释放池会被清空，所有存储在其中的对象都会被释放。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol>
<li><strong>临时对象</strong>：在方法中创建临时对象并返回，而不需要担心手动释放对象。</li>
<li><strong>批量操作</strong>：在循环中创建大量对象时使用，避免在循环中频繁手动释放对象。</li>
</ol>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下示例展示了 <code>autorelease</code> 的使用：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">- (NSString *)temporaryString &#123;</span><br><span class="line">    NSString *string = [[[NSString alloc] initWithFormat:@&quot;Hello, World!&quot;] autorelease];</span><br><span class="line">    return string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这个例子中，<code>initWithFormat:</code> 方法创建了一个新的 <code>NSString</code> 对象。调用 <code>autorelease</code> 方法将这个对象添加到当前的自动释放池中。这样，当方法返回时，不需要手动释放 <code>string</code> 对象，它将在自动释放池被清空时自动释放。</p>
<h3 id="自动释放池的创建和销毁"><a href="#自动释放池的创建和销毁" class="headerlink" title="自动释放池的创建和销毁"></a>自动释放池的创建和销毁</h3><p>在 iOS 应用程序中，自动释放池通常由框架自动管理，开发者不需要显式地创建和销毁自动释放池。然而，在某些情况下，如创建大量临时对象或在非主线程中工作时，可能需要手动管理自动释放池。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 手动创建和销毁自动释放池</span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">    for (int i = 0; i &lt; 1000; i++) &#123;</span><br><span class="line">        NSString *string = [[[NSString alloc] initWithFormat:@&quot;Number %d&quot;, i] autorelease];</span><br><span class="line">        NSLog(@&quot;%@&quot;, string);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这个例子中，<code>@autoreleasepool</code> 块创建了一个新的自动释放池。所有在该块中被 <code>autorelease</code> 的对象将在块结束时自动释放。</p>
<h3 id="自动释放池的注意事项"><a href="#自动释放池的注意事项" class="headerlink" title="自动释放池的注意事项"></a>自动释放池的注意事项</h3><ul>
<li><strong>性能考虑</strong>：频繁创建和销毁大量对象时，使用自动释放池可以帮助管理内存，但要注意不要在紧密循环中频繁使用 <code>autorelease</code>，可能会导致性能问题。</li>
<li><strong>非主线程</strong>：在非主线程中工作时，确保有一个自动释放池。如果没有显式创建，可能会导致内存泄漏。</li>
</ul>
<h3 id="自动释放池在-ARC-中的表现"><a href="#自动释放池在-ARC-中的表现" class="headerlink" title="自动释放池在 ARC 中的表现"></a>自动释放池在 ARC 中的表现</h3><p>在 ARC 环境中，<code>autorelease</code> 和自动释放池仍然存在，但 ARC 自动管理对象的内存，大多数情况下不需要显式调用 <code>autorelease</code>。然而，理解自动释放池的工作原理仍然很重要，特别是在处理性能优化和非主线程时。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>**<code>autorelease</code>**：延迟释放对象，将对象添加到自动释放池中。</li>
<li><strong>自动释放池</strong>：存储 <code>autorelease</code> 对象，生命周期与运行循环对应。</li>
<li><strong>使用场景</strong>：临时对象、批量操作、非主线程。</li>
<li><strong>手动管理</strong>：在需要时显式创建和销毁自动释放池，确保内存管理正确。</li>
</ul>
<p>通过理解和正确使用 <code>autorelease</code> 和自动释放池，开发者可以更有效地管理内存，避免内存泄漏和提升应用性能。</p>
<h1 id="自动释放池的前世今生-—-深入解析-autoreleasepool"><a href="#自动释放池的前世今生-—-深入解析-autoreleasepool" class="headerlink" title="自动释放池的前世今生 —- 深入解析 autoreleasepool"></a>自动释放池的前世今生 —- 深入解析 autoreleasepool</h1><p><a class="link"   href="https://draveness.me/autoreleasepool/" >https://draveness.me/autoreleasepool/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>autorelease</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS中 Core Foundation 不支持 ARC</title>
    <url>/2024/07/22/iOS/OC/002-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/007-Core%20Foundation%E4%B8%8D%E6%94%AF%E6%8C%81ARC/README/</url>
    <content><![CDATA[<!-- # iOS中 Core Foundation 不支持 ARC -->

<p>Core Foundation（CF）是一个底层的C语言框架，用于iOS和macOS开发。它不支持自动引用计数（ARC），因此在使用Core Foundation的API时，开发者需要手动管理内存。</p>
<span id="more"></span>

<h3 id="Core-Foundation-与-ARC"><a href="#Core-Foundation-与-ARC" class="headerlink" title="Core Foundation 与 ARC"></a>Core Foundation 与 ARC</h3><p>在使用Core Foundation的对象时，以下几点需要特别注意：</p>
<ol>
<li><p><strong>手动管理内存</strong>：与Objective-C对象不同，Core Foundation对象必须手动管理其生命周期。这意味着需要手动调用<code>CFRetain</code>和<code>CFRelease</code>来管理对象的引用计数。</p>
</li>
<li><p><strong>内存管理规则</strong>：Core Foundation遵循特定的内存管理规则，如Create Rule和Get Rule。</p>
<ul>
<li><strong>Create Rule</strong>：任何带有<code>Create</code>或<code>Copy</code>的函数（例如<code>CFStringCreateWithCString</code>）会返回一个新创建的对象，调用者负责管理其生命周期，并在不需要时调用<code>CFRelease</code>。</li>
<li><strong>Get Rule</strong>：任何不带有<code>Create</code>或<code>Copy</code>的函数（例如<code>CFArrayGetValueAtIndex</code>）返回的对象由调用者不负责管理。</li>
</ul>
</li>
<li><p><strong>桥接 Core Foundation 和 Objective-C 对象</strong>：Core Foundation对象和Objective-C对象之间的转换需要桥接，通常通过<code>__bridge</code>、<code>__bridge_retained</code>、<code>__bridge_transfer</code>来实现。</p>
</li>
</ol>
<h3 id="桥接示例"><a href="#桥接示例" class="headerlink" title="桥接示例"></a>桥接示例</h3><p>以下是一些常见的桥接示例，用于在Core Foundation和Objective-C对象之间转换，并管理内存：</p>
<h4 id="将-Core-Foundation-对象转换为-Objective-C-对象"><a href="#将-Core-Foundation-对象转换为-Objective-C-对象" class="headerlink" title="将 Core Foundation 对象转换为 Objective-C 对象"></a>将 Core Foundation 对象转换为 Objective-C 对象</h4><p>如果需要将Core Foundation对象转换为Objective-C对象，并且希望ARC管理Objective-C对象的生命周期，可以使用<code>__bridge_transfer</code>。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">CFStringRef cfString = CFStringCreateWithCString(NULL, &quot;Hello, World!&quot;, kCFStringEncodingUTF8);</span><br><span class="line">NSString *objcString = (__bridge_transfer NSString *)cfString;</span><br><span class="line">// objcString 将被 ARC 管理，不需要手动调用 CFRelease(cfString)</span><br></pre></td></tr></table></figure></div>

<h4 id="将-Objective-C-对象转换为-Core-Foundation-对象"><a href="#将-Objective-C-对象转换为-Core-Foundation-对象" class="headerlink" title="将 Objective-C 对象转换为 Core Foundation 对象"></a>将 Objective-C 对象转换为 Core Foundation 对象</h4><p>如果需要将Objective-C对象转换为Core Foundation对象，并且希望手动管理Core Foundation对象的生命周期，可以使用<code>__bridge_retained</code>。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSString *objcString = @&quot;Hello, World!&quot;;</span><br><span class="line">CFStringRef cfString = (__bridge_retained CFStringRef)objcString;</span><br><span class="line">// 需要手动调用 CFRelease(cfString) 来释放内存</span><br><span class="line">CFRelease(cfString);</span><br></pre></td></tr></table></figure></div>

<h3 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h3><p>以下是一个完整示例，演示了在ARC环境下如何使用Core Foundation对象，并正确地进行内存管理：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line">#import &lt;CoreFoundation/CoreFoundation.h&gt;</span><br><span class="line"></span><br><span class="line">void createAndUseCoreFoundationObject() &#123;</span><br><span class="line">    // 创建 Core Foundation 对象</span><br><span class="line">    CFStringRef cfString = CFStringCreateWithCString(NULL, &quot;Hello, World!&quot;, kCFStringEncodingUTF8);</span><br><span class="line">    </span><br><span class="line">    // 将 Core Foundation 对象转换为 Objective-C 对象</span><br><span class="line">    NSString *objcString = (__bridge_transfer NSString *)cfString;</span><br><span class="line">    NSLog(@&quot;Objective-C String: %@&quot;, objcString);</span><br><span class="line">    </span><br><span class="line">    // Core Foundation 对象被 ARC 管理，不需要手动释放</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void convertAndManageObjectiveCObject() &#123;</span><br><span class="line">    // 创建 Objective-C 对象</span><br><span class="line">    NSString *objcString = @&quot;Hello, World!&quot;;</span><br><span class="line">    </span><br><span class="line">    // 将 Objective-C 对象转换为 Core Foundation 对象</span><br><span class="line">    CFStringRef cfString = (__bridge_retained CFStringRef)objcString;</span><br><span class="line">    </span><br><span class="line">    // 使用 Core Foundation 对象</span><br><span class="line">    CFShow(cfString);</span><br><span class="line">    </span><br><span class="line">    // 手动释放 Core Foundation 对象</span><br><span class="line">    CFRelease(cfString);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        createAndUseCoreFoundationObject();</span><br><span class="line">        convertAndManageObjectiveCObject();</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Core Foundation不支持ARC，因此在使用Core Foundation对象时，开发者需要手动管理内存。这包括遵循Create Rule和Get Rule，以及正确地使用桥接来转换Core Foundation和Objective-C对象。理解这些规则和技巧，有助于在ARC环境中正确、安全地使用Core Foundation。</p>
<h1 id="关于-Toll-Free-Bridging"><a href="#关于-Toll-Free-Bridging" class="headerlink" title="关于 Toll-Free Bridging"></a>关于 Toll-Free Bridging</h1><ul>
<li>__bridge（修饰符）</li>
<li>__bridge_retained（修饰符） or CFBridgingRetain（函数）</li>
<li>__bridge_transfer（修饰符） or CFBridgingRelease（函数）</li>
</ul>
<p><a class="link"   href="https://www.samirchen.com/ios-arc/" >https://www.samirchen.com/ios-arc/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>ARC</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是空指针、野指针？</title>
    <url>/2024/07/22/iOS/OC/002-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/011-%E7%A9%BA%E6%8C%87%E9%92%88%E3%80%81%E9%87%8E%E6%8C%87%E9%92%88/README/</url>
    <content><![CDATA[<p><a class="link"   href="https://www.cnblogs.com/mjios/archive/2013/04/22/3034788.html" >【Objective-C】09-空指针和野指针 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<!-- # 什么是空指针、野指针？ -->

<ul>
<li><p>空指针：</p>
<p>  1&gt; 没有存储任何内存地址的指针就称为空指针(NULL指针)</p>
<p>  2&gt; 空指针就是被赋值为0的指针，在没有被具体初始化之前，其值为0。</p>
  <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Student *s1 = NULL;</span><br><span class="line">Student *s2 = nil;</span><br></pre></td></tr></table></figure></div></li>
</ul>
 <span id="more"></span>

<ul>
<li><p>野指针：</p>
<p>  “野指针”不是NULL指针，是指向”垃圾”内存（不可用内存）的指针。野指针是非常危险的。向野指针发送消息会导致崩溃。野指针错误形式在Xcode中通常表现为：Thread 1：EXC_BAD_ACCESS，因为你访问了一块已经不属于你的内存。</p>
</li>
<li><p>野指针，有指向，而空指针无指向，为NULL</p>
</li>
</ul>
<p><strong>空指针</strong>表示指针不指向任何对象或内存，可以安全地检查和处理。</p>
<p><strong>野指针</strong>指向已经释放或未分配的内存，使用它们会导致未定义行为，需要小心处理。</p>
<h1 id="野指针如何产生？"><a href="#野指针如何产生？" class="headerlink" title="野指针如何产生？"></a>野指针如何产生？</h1><blockquote>
<ol>
<li><p>指针变量未初始化</p>
<p> 任何指针变量刚被创建时不会自动成为NULL指针，它的缺省值是随机的，它会乱指一气。所以，指针变量在创建的同时应当被初始化，要么将指针设置为NULL，要么让它指向合法的内存。</p>
</li>
<li><p>指针释放后之后未置空</p>
<p> 有时指针在free或delete后未赋值 NULL，便会使人以为是合法的。别看free和delete的名字（尤其是delete），它们只是把指针所指的内存给释放掉，但并没有把指针本身干掉。此时指针指向的就是“垃圾”内存。释放后的指针应立即将指针置为NULL，防止产生“野指针”。</p>
</li>
<li><p>指针操作超越变量作用域</p>
<p> 不要返回指向栈内存的指针或引用，因为栈内存在函数结束时会被释放。</p>
</li>
</ol>
</blockquote>
<p><strong>释放对象后没有将指针置为 nil</strong>： 当你手动释放一个对象后，如果没有将指向该对象的指针置为 nil，该指针就变成了野指针。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">objective</span><br><span class="line">复制代码</span><br><span class="line">MyClass *obj = [[MyClass alloc] init];</span><br><span class="line">[obj release]; // obj 指向的内存被释放了</span><br><span class="line">// obj 现在是野指针</span><br></pre></td></tr></table></figure></div>





<p>示例一：</p>
<p>assign可以用来修饰OC对象，会造成野指针。 unsafe_unretained声明一个弱引用，但不会自动置为nil，会出现野指针。</p>
<p>示例二：</p>
<p>自定义Student类，在main函数中添加下列代码</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">Student *stu = [[Student alloc] init];</span><br><span class="line"></span><br><span class="line">[stu setAge:10];</span><br><span class="line"></span><br><span class="line">[stu release];</span><br><span class="line"></span><br><span class="line">[stu setAge:10];</span><br></pre></td></tr></table></figure></div>

<p>运行程序，你会发现<code>[stu setAge:10];</code>报错了，是个野指针错误！</p>
<p><strong>分析一下报错原因</strong></p>
<p>1&gt; 执行完第1行代码后，内存中有个指针变量stu，指向了Student对象 <code>Student *stu = [[Student alloc] init];</code></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/22/iOS/OC/002-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/011-%E7%A9%BA%E6%8C%87%E9%92%88%E3%80%81%E9%87%8E%E6%8C%87%E9%92%88/README/005.png"
                      alt="img"
                ></p>
<p>假设Student对象的地址为0xff43，指针变量stu的地址为0xee45，stu中存储的是Student对象的地址0xff43。即指针变量stu指向了这个Student对象。</p>
<p>2&gt; 接下来是第3行代码: <code>[stu setAge:10];</code></p>
<p>这行代码的意思是：给stu所指向的Student对象发送一条setAge:消息，即调用这个Student对象的setAge:方法。目前来说，这个Student对象仍存在于内存中，所以这句代码没有任何问题。</p>
<p>3&gt; 接下来是第5行代码: <code>[stu release];</code></p>
<p>这行代码的意思是：给stu指向的Student对象发送一条release消息。在这里，Student对象接收到release消息后，会马上被销毁，所占用的内存会被回收。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/22/iOS/OC/002-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/011-%E7%A9%BA%E6%8C%87%E9%92%88%E3%80%81%E9%87%8E%E6%8C%87%E9%92%88/README/006.png"
                      alt="img"
                ></p>
<p>Student对象被销毁了，地址为0xff43的内存就变成了”垃圾内存”，然而，指针变量stu仍然指向这一块内存，这时候，stu就称为了<strong>野指针！</strong></p>
<p>4&gt; 最后执行了第7行代码: <code>[stu setAge:10];</code></p>
<p>这句代码的意思仍然是： 给stu所指向的Student对象发送一条setAge:消息。但是在执行完第5行代码后，Student对象已经被销毁了，它所占用的内存已经是垃圾内存，如果你还去访问这一块内存，那就会报野指针错误。这块内存已经不可用了，也不属于你了，你还去访问它，肯定是不合法的。所以，这行代码报错了！</p>
<p>5&gt; 如果修改下代码： </p>
<div class="highlight-container" data-rel="Objc"><figure class="iseeu highlight objc"><table><tr><td class="code"><pre><span class="line">Student *stu = [[Student alloc] init];</span><br><span class="line"></span><br><span class="line">[stu setAge:<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">[stu release];</span><br><span class="line"></span><br><span class="line">stu = <span class="literal">nil</span>;   <span class="comment">// stu变成了空指针，stu就不再指向任何内存了</span></span><br><span class="line"></span><br><span class="line">[stu setAge:<span class="number">10</span>];</span><br></pre></td></tr></table></figure></div>

<p> <img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/22/iOS/OC/002-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/011-%E7%A9%BA%E6%8C%87%E9%92%88%E3%80%81%E9%87%8E%E6%8C%87%E9%92%88/README/007.png"
                      alt="img"
                ></p>
<p>因为stu是个空指针，没有指向任何对象，因此第9行的setAge:消息是发不出去的，不会造成任何影响。当然，肯定也不会报错。</p>
<h1 id="防止野指针的方法"><a href="#防止野指针的方法" class="headerlink" title="防止野指针的方法"></a>防止野指针的方法</h1><ol>
<li><p><strong>将指针置为 nil</strong>： 在释放对象后，将指针置为 nil 可以防止野指针。</p>
 <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">objective</span><br><span class="line">复制代码</span><br><span class="line">MyClass *obj = [[MyClass alloc] init];</span><br><span class="line">[obj release];</span><br><span class="line">obj = nil; // 防止野指针</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>使用自动引用计数（ARC）</strong>： ARC 自动管理对象的内存，避免手动管理引用计数，从而减少野指针的产生。</p>
 <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">objective</span><br><span class="line">复制代码</span><br><span class="line">@interface MyClass : NSObject</span><br><span class="line">@property (nonatomic, strong) NSString *name;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MyClass</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div>
</li>
<li><p><strong>使用弱引用（weak）</strong>： 使用弱引用（weak）来防止循环引用和野指针。弱引用在引用对象被释放后自动置为 nil。</p>
 <div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">objective</span><br><span class="line">复制代码</span><br><span class="line">@interface MyClass : NSObject</span><br><span class="line">@property (nonatomic, weak) id&lt;Delegate&gt; delegate;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MyClass</span><br><span class="line">@end</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h1 id="野指针的定位"><a href="#野指针的定位" class="headerlink" title="野指针的定位"></a>野指针的定位</h1><p><a class="link"   href="https://www.jianshu.com/p/8aba0ee41cd7" >iOS野指针定位总结 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://www.jianshu.com/p/a9014c4f379d" >iOS 通向野指针的必经之路 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="检测和调试野指针"><a href="#检测和调试野指针" class="headerlink" title="检测和调试野指针"></a>检测和调试野指针</h3><ol>
<li><p><strong>启用僵尸对象（Zombie Objects）</strong>： Xcode 提供了启用僵尸对象的选项，可以帮助检测野指针。启用僵尸对象后，被释放的对象会变成僵尸对象，当对僵尸对象发送消息时，会抛出异常，帮助你找到问题所在。</p>
<p> 启用僵尸对象：</p>
<ul>
<li>选择你的项目。</li>
<li>在左侧栏中选择 “Edit Scheme”。</li>
<li>选择 “Run” 标签，然后选择 “Diagnostics”。</li>
<li>勾选 “Enable Zombie Objects”。</li>
</ul>
</li>
<li><p><strong>Address Sanitizer</strong>： Address Sanitizer 是一个运行时工具，可以检测内存错误，包括使用野指针。可以在 Xcode 中启用 Address Sanitizer 进行检测。</p>
<p> 启用 Address Sanitizer：</p>
<ul>
<li>选择你的项目。</li>
<li>在左侧栏中选择 “Edit Scheme”。</li>
<li>选择 “Run” 标签，然后选择 “Diagnostics”。</li>
<li>勾选 “Address Sanitizer”。</li>
</ul>
</li>
</ol>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>空指针</tag>
        <tag>野指针</tag>
      </tags>
  </entry>
  <entry>
    <title>内存区域</title>
    <url>/2024/07/30/iOS/OC/002-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/023-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/README/</url>
    <content><![CDATA[<p>iOS 中的内存主要分为五大区域：</p>
<p>Text Segment（代码段）：存储应用程序的代码，包括可执行代码和只读数据。<br>Data Segment（数据段）：存储应用程序的初始化数据，包括全局变量和静态变量。<br>Heap（堆）：用于动态分配内存，存储应用程序在运行时创建的对象和数据。<br>Stack（栈）：用于存储函数调用相关的信息，包括函数参数、返回地址和局部变量。<br>BSS Segment（未初始化数据段）：存储应用程序的未初始化数据，包括全局变量和静态变量。<br>栈和堆是两个主要的内存区域，它们有着不同的特点和用途：</p>
<p>栈（Stack）：</p>
<p>栈是一块连续的内存区域，用于存储函数调用相关的信息。<br>栈的内存是自动分配和释放的，不需要手动管理。<br>栈上的数据包括函数参数、返回地址、局部变量和函数调用链信息。<br>栈的大小是固定的，通常在编译时确定。<br>堆（Heap）：</p>
<p>堆是一块动态分配的内存区域，用于存储应用程序在运行时创建的对象和数据。<br>堆的内存需要手动管理，使用 malloc、free 等函数来分配和释放内存。<br>堆上的数据包括动态创建的对象、数组和结构体等。<br>堆的大小可以动态变化，取决于应用程序的需求。<br>在 iOS 中，以下数据通常存储在栈上：</p>
<p>函数参数<br>局部变量<br>函数返回地址<br>函数调用链信息<br>以下数据通常存储在堆上：</p>
<p>动态创建的对象<br>数组和结构体<br>字符串和其他动态分配的数据<br>需要注意的是，iOS 中的内存管理主要使用 ARC（Automatic Reference Counting）机制，ARC 会自动管理堆上的内存，开发者无需手动释放内存。</p>
<div class="highlight-container" data-rel="C"><figure class="iseeu highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">10</span>;   <span class="comment">// 全局初始化区</span></span><br><span class="line"><span class="type">char</span> *p;    <span class="comment">// 全局未初始化区</span></span><br><span class="line"> </span><br><span class="line">main &#123;</span><br><span class="line">   <span class="type">int</span> b;   <span class="comment">// 栈区</span></span><br><span class="line">   <span class="type">char</span> s[] = <span class="string">&quot;abc&quot;</span>;   <span class="comment">// 栈区</span></span><br><span class="line">   <span class="type">char</span> *p1;   <span class="comment">// 栈区</span></span><br><span class="line">   <span class="type">char</span> *p2 = <span class="string">&quot;123456&quot;</span>;   <span class="comment">// 123456 在常量区，p2在栈上</span></span><br><span class="line">   <span class="type">static</span> <span class="type">int</span> c = <span class="number">0</span>;   <span class="comment">// 全局(静态)初始化区</span></span><br><span class="line">    </span><br><span class="line">   w1 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">   w2 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">20</span>);   <span class="comment">// 分配得来的10和20字节的区域就在堆区。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title>反射是什么？</title>
    <url>/2024/07/30/iOS/OC/003-OC%E6%96%B9%E6%B3%95/015-%E5%8F%8D%E5%B0%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/README/</url>
    <content><![CDATA[<p>在iOS开发中，反射（Reflection）是指在运行时动态检查和操作对象、类型、属性和方法的能力。通过反射，你可以在代码中动态地获取类型信息、调用方法、访问属性等，而无需在编译时知道这些信息。</p>
<span id="more"></span>

<p>获取Class的三种方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 通过字符串获取class  </span><br><span class="line">Class class = NSClassFromString(@&quot;NSString&quot;);  </span><br><span class="line">NSLog(@&quot;class type : %@&quot;, class);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 直接用class 来创建对象 ,通过对象来获取class </span><br><span class="line">id str = [[class alloc] init];   </span><br><span class="line">NSLog(@&quot;%@&quot;, [str class]);  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 通过类来获取class  </span><br><span class="line">NSLog(@&quot;%d&quot;, class==NSString.class);   </span><br></pre></td></tr></table></figure></div>


<p>常用判断方法</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 当前对象是否这个类或其子类的实例</span><br><span class="line">- (BOOL)isKindOfClass:(Class)aClass;</span><br><span class="line"></span><br><span class="line">// 当前对象是否是这个类的实例</span><br><span class="line">- (BOOL)isMemberOfClass:(Class)aClass;</span><br><span class="line"></span><br><span class="line">// 当前对象是否遵守这个协议</span><br><span class="line">- (BOOL)conformsToProtocol:(Protocol *)aProtocol;</span><br><span class="line"></span><br><span class="line">// 当前对象是否实现这个方法</span><br><span class="line">- (BOOL)respondsToSelector:(SEL)aSelector;</span><br></pre></td></tr></table></figure></div>


<h1 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h1><p>在iOS开发中，反射（Reflection）是指在运行时动态检查和操作对象、类型、属性和方法的能力。通过反射，你可以在代码中动态地获取类型信息、调用方法、访问属性等，而无需在编译时知道这些信息。</p>
<h3 id="反射的常见用途"><a href="#反射的常见用途" class="headerlink" title="反射的常见用途"></a>反射的常见用途</h3><ol>
<li><strong>动态类型检查</strong>：在运行时检查对象的类型。</li>
<li><strong>动态方法调用</strong>：在运行时调用对象的方法。</li>
<li><strong>动态属性访问</strong>：在运行时访问对象的属性。</li>
<li><strong>序列化和反序列化</strong>：将对象转换为可传输格式（如JSON），或将传输格式转换回对象。</li>
</ol>
<h3 id="Objective-C中的反射"><a href="#Objective-C中的反射" class="headerlink" title="Objective-C中的反射"></a>Objective-C中的反射</h3><p>Objective-C由于其动态特性，支持广泛的反射操作。常用的反射相关方法和类包括：</p>
<ul>
<li><code>NSObject</code>类的方法：<ul>
<li><code>class</code></li>
<li><code>superclass</code></li>
<li><code>isKindOfClass:</code></li>
<li><code>isMemberOfClass:</code></li>
<li><code>respondsToSelector:</code></li>
<li><code>performSelector:</code></li>
<li><code>conformsToProtocol:</code></li>
</ul>
</li>
<li><code>NSClassFromString</code></li>
<li><code>NSStringFromClass</code></li>
<li><code>NSSelectorFromString</code></li>
<li><code>NSStringFromSelector</code></li>
</ul>
<h4 id="示例：动态类型检查和方法调用"><a href="#示例：动态类型检查和方法调用" class="headerlink" title="示例：动态类型检查和方法调用"></a>示例：动态类型检查和方法调用</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#import &lt;Foundation/Foundation.h&gt;</span><br><span class="line"></span><br><span class="line">@interface MyClass : NSObject</span><br><span class="line">- (void)sayHello;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation MyClass</span><br><span class="line">- (void)sayHello &#123;</span><br><span class="line">    NSLog(@&quot;Hello, World!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">int main(int argc, const char * argv[]) &#123;</span><br><span class="line">    @autoreleasepool &#123;</span><br><span class="line">        // 动态创建类实例</span><br><span class="line">        Class myClass = NSClassFromString(@&quot;MyClass&quot;);</span><br><span class="line">        id myObject = [[myClass alloc] init];</span><br><span class="line">        </span><br><span class="line">        // 动态检查类型</span><br><span class="line">        if ([myObject isKindOfClass:myClass]) &#123;</span><br><span class="line">            NSLog(@&quot;myObject is kind of MyClass&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        // 动态调用方法</span><br><span class="line">        SEL selector = NSSelectorFromString(@&quot;sayHello&quot;);</span><br><span class="line">        if ([myObject respondsToSelector:selector]) &#123;</span><br><span class="line">            [myObject performSelector:selector];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>输出：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">myObject is kind of MyClass</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure></div>

<p>在这个示例中，<code>NSClassFromString</code>用于动态获取类，<code>NSSelectorFromString</code>用于动态获取方法选择器，<code>performSelector:</code>用于动态调用方法。</p>
<h3 id="Swift中的反射"><a href="#Swift中的反射" class="headerlink" title="Swift中的反射"></a>Swift中的反射</h3><p>Swift也支持反射，但由于其更强的类型安全和编译时检查，Swift的反射功能比Objective-C有限。Swift提供了<code>Mirror</code>类型来进行反射操作。</p>
<h4 id="示例：使用Mirror进行反射"><a href="#示例：使用Mirror进行反射" class="headerlink" title="示例：使用Mirror进行反射"></a>示例：使用<code>Mirror</code>进行反射</h4><div class="highlight-container" data-rel="Swift"><figure class="iseeu highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> name: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span>(<span class="params">name</span>: <span class="type">String</span>, <span class="params">age</span>: <span class="type">Int</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.name <span class="operator">=</span> name</span><br><span class="line">        <span class="keyword">self</span>.age <span class="operator">=</span> age</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">sayHello</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObject <span class="operator">=</span> <span class="type">MyClass</span>(name: <span class="string">&quot;John&quot;</span>, age: <span class="number">30</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用Mirror进行反射</span></span><br><span class="line"><span class="keyword">let</span> mirror <span class="operator">=</span> <span class="type">Mirror</span>(reflecting: myObject)</span><br><span class="line"><span class="keyword">for</span> child <span class="keyword">in</span> mirror.children &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> label <span class="operator">=</span> child.label &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;<span class="subst">\(label)</span>: <span class="subst">\(child.value)</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>输出：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">name: John</span><br><span class="line">age: 30</span><br></pre></td></tr></table></figure></div>

<p>在这个示例中，<code>Mirror</code>用于反射<code>myObject</code>的属性和值。需要注意的是，Swift的反射功能更注重属性的获取，而不是动态方法调用。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>反射在iOS开发中提供了强大的动态能力，允许在运行时检查和操作对象的类型、属性和方法。Objective-C提供了广泛的反射功能，而Swift也提供了基本的反射能力，主要用于属性的获取和操作。在实际开发中，合理使用反射可以提高代码的灵活性和适应性，但过度使用反射可能会影响性能和代码的可维护性。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS中UIView与CALayer</title>
    <url>/2024/08/09/iOS/OC/003-OC%E6%96%B9%E6%B3%95/001-UIView%E4%B8%8ECALayer/index/</url>
    <content><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a class="link"   href="https://coderlawrence.github.io/2020/03/04/UIView%E4%B8%8ECALayer%E7%9A%84%E5%85%B3%E7%B3%BB/" >UIView与CALayer的关系 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><h2 id="UIView继承关系"><a href="#UIView继承关系" class="headerlink" title="UIView继承关系"></a>UIView继承关系</h2><p>首先我们要理解UIView以及它的一个继承关系等</p>
<p>UIView表示屏幕上的一块矩形区域，它是基本上iOS所有可视化控件的父类，UIView可以管理矩形区域里的内容，处理矩形区域的事件，包括对子视图的管理以及动画的实现。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/08/09/iOS/OC/003-OC%E6%96%B9%E6%B3%95/001-UIView%E4%B8%8ECALayer/index/001.png"
                     
                ></p>
<p>上面的图是UIKit相关类的继承关系，从上面可以看出，UIView继承自UIResponder，所以UIView可以做事件响应，它也是iOS中所有视图（控件）直接或者间接的父类。</p>
<h2 id="UIResponder介绍"><a href="#UIResponder介绍" class="headerlink" title="UIResponder介绍"></a>UIResponder介绍</h2><p>在UIKit中UIResponder作为响应事件的对象，来响应系统传递过来的事件并进行处理。在UIResponder中定义了处理各种事件传递的接口。<br>UIApplication、UIViewController、UIView、和所有从UIView派生出来的UIKit类（包括UIWindow）都直接或间接地继承自UIResponder类。<br>而CALayer直接继承NSObject，并没有相应的处理事件的接口。</p>
<h2 id="UIView与CALayer的区别"><a href="#UIView与CALayer的区别" class="headerlink" title="UIView与CALayer的区别"></a>UIView与CALayer的区别</h2><ol>
<li><p>UIView能够响应事件，CALayer不可以</p>
</li>
<li><p>UIView是CALayer的delegate，当CALayer属性改变、动画产生时，UIView能够得到通知；</p>
</li>
<li><p>UIView只是处理事件，CALayer主要负责图层的绘制</p>
</li>
<li><p>UIView 和 CALayer 不是线程安全的，并且只能在主线程创建、访问和销毁。</p>
</li>
<li><p>每个UIView内部都有一个CALayer在背后提供内容绘制和显示，而且UIView的尺寸样式都由内部的Layer所提供。两者都有树状层级结构，layer内部有SubLayers，View内部有SubViews。但是Layer比View多了AnchorPoint</p>
</li>
<li><p>一个Layer的frame是由它anchorPoint,position,bounds,和 transform 共同决定的，而一个View的frame只是简单的返回Layer的frame</p>
</li>
<li><p>在iOS做动画的时候，修改非RootLayer的属性（譬如位置、背景色等）会默认产生隐式动画，而修改UIView则不会</p>
</li>
<li><p>常用：向UIView的layer上添加子layer，来使目标View上敷上一层黑色的透明薄膜。</p>
<div class="highlight-container" data-rel="Objc"><figure class="iseeu highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">CALayer</span> *grayCover = [[<span class="built_in">CALayer</span> alloc] init];</span><br><span class="line">grayCover.backgroudColor = [[<span class="built_in">UIColor</span> blackColor]colorWithAlphaComponent:<span class="number">0.3</span>].CGColor;</span><br><span class="line">[<span class="keyword">self</span>.layer addSubLayer: grayCover];</span><br></pre></td></tr></table></figure></div></li>
</ol>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>CALayer</tag>
        <tag>UIView</tag>
      </tags>
  </entry>
  <entry>
    <title>frame 和 bounds</title>
    <url>/2024/07/30/iOS/OC/003-OC%E6%96%B9%E6%B3%95/017-frame%E5%92%8Cbounds/README/</url>
    <content><![CDATA[<p><a class="link"   href="https://www.jianshu.com/p/964313cfbdaa" >frame和bounds的区别 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<ul>
<li>frame: 该view在父view坐标系统中的位置和大小。（参照点是，父亲的坐标系统）</li>
<li>bounds：该view在本地坐标系统中的位置和大小。（参照点是，本地坐标系统，就相当于ViewB自己的坐标系统，以0,0点为起点）</li>
</ul>
<span id="more"></span>

<h1 id="frame和bounds简介"><a href="#frame和bounds简介" class="headerlink" title="frame和bounds简介"></a>frame和bounds简介</h1><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/30/iOS/OC/003-OC%E6%96%B9%E6%B3%95/017-frame%E5%92%8Cbounds/README/001.webp"
                     
                ></p>
<ul>
<li>frame: 该view在父view坐标系统中的位置和大小。（参照点是，父亲的坐标系统）</li>
<li>bounds：该view在本地坐标系统中的位置和大小。（参照点是，本地坐标系统，就相当于ViewB自己的坐标系统，以0,0点为起点）。</li>
</ul>
<p>其实本地坐标系统的关键就是要知道的它的原点（0，0）在父坐标系统中的什么位置（这个位置是相对于父view的本地坐标系统而言的，最终的父view就是UIWindow，它的本地坐标系统原点就是屏幕的左上角了）。</p>
<p>通过修改view的bounds属性可以修改本地坐标系统的原点位置。</p>
<h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">UIView *view1 = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 200, 200)];</span><br><span class="line">view1.backgroundColor = [UIColor redColor];</span><br><span class="line">[self.view addSubview:view1];//添加到self.view</span><br><span class="line">NSLog(@&quot;view1 frame:%@========view1 bounds:%@&quot;,NSStringFromCGRect(view1.frame),NSStringFromCGRect(view1.bounds));</span><br><span class="line"></span><br><span class="line">UIView *view2 = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];</span><br><span class="line">view2.backgroundColor = [UIColor yellowColor];</span><br><span class="line">[view1 addSubview:view2];//添加到view1上,[此时view1坐标系左上角起点为(-20,-20)]</span><br><span class="line">NSLog(@&quot;view2 frame:%@========view2 bounds:%@&quot;,NSStringFromCGRect(view2.frame),NSStringFromCGRect(view2.bounds));</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/30/iOS/OC/003-OC%E6%96%B9%E6%B3%95/017-frame%E5%92%8Cbounds/README/002.webp"
                     
                ></p>
<p>输出</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">view1 frame:&#123;&#123;100, 100&#125;, &#123;200, 200&#125;&#125;========view1 bounds:&#123;&#123;0, 0&#125;, &#123;200, 200&#125;&#125;</span><br><span class="line">view2 frame:&#123;&#123;0, 0&#125;, &#123;100, 100&#125;&#125;========view2 bounds:&#123;&#123;0, 0&#125;, &#123;100, 100&#125;&#125;</span><br></pre></td></tr></table></figure></div>

<p>下面我们来改变view1的bounds，代码如下</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[view1 setBounds:CGRectMake(-20, -20, 200, 200)];</span><br></pre></td></tr></table></figure></div>

<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/30/iOS/OC/003-OC%E6%96%B9%E6%B3%95/017-frame%E5%92%8Cbounds/README/003.webp"
                     
                ></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">view1 frame:&#123;&#123;100, 100&#125;, &#123;200, 200&#125;&#125;========view1 bounds:&#123;&#123;-20, -20&#125;, &#123;200, 200&#125;&#125;</span><br><span class="line">view2 frame:&#123;&#123;0, 0&#125;, &#123;100, 100&#125;&#125;========view2 bounds:&#123;&#123;0, 0&#125;, &#123;100, 100&#125;&#125;</span><br></pre></td></tr></table></figure></div>


<h1 id="bouns大于frame的情况"><a href="#bouns大于frame的情况" class="headerlink" title="bouns大于frame的情况"></a>bouns大于frame的情况</h1><p>假设设置了控件的bounds大于frame，那么此时会导致frame被撑大，frame的x,y,width,height都会改变。</p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/07/30/iOS/OC/003-OC%E6%96%B9%E6%B3%95/017-frame%E5%92%8Cbounds/README/004.webp"
                     
                ></p>
<h1 id="问：frame-和-bounds-分别是用来做什么的？"><a href="#问：frame-和-bounds-分别是用来做什么的？" class="headerlink" title="问：frame 和 bounds 分别是用来做什么的？"></a>问：frame 和 bounds 分别是用来做什么的？</h1><ul>
<li><p>frame是参考父view的坐标系来设置自己左上角的位置。</p>
</li>
<li><p>设置bounds可以修改自己坐标系的原点位置，进而影响到其“子view”的显示位置。</p>
</li>
<li><p>bounds使用场景：</p>
<p>  其实bounds我们一直在使用，就是我们使用scrollview的时候。</p>
<p>  为什么我们滚动scrollview可以看到超出显示屏的内容。就是因为scrollview在不断改变自己的bounds，从而改变scrollview上的子view的frame，让他们的frame始终在最顶级view（window）的frame内部，这样我们就可以始终看到内容了。</p>
</li>
</ul>
<h1 id="问：frame-和-bound-一定都相等么？如果有不等的情况，请举例说明"><a href="#问：frame-和-bound-一定都相等么？如果有不等的情况，请举例说明" class="headerlink" title="问：frame 和 bound 一定都相等么？如果有不等的情况，请举例说明"></a>问：frame 和 bound 一定都相等么？如果有不等的情况，请举例说明</h1><p><a class="link"   href="https://blog.csdn.net/lihao_ios/article/details/107540979" >iOS日常开发之frame和bounds的不同 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://halfrost.com/ios_interview/" >2016年3月 iOS 面试总结 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>frame</tag>
        <tag>bounds</tag>
      </tags>
  </entry>
  <entry>
    <title>imageName 和 imageWithContextOfFile 的区别？哪个性能高？</title>
    <url>/2024/07/30/iOS/OC/003-OC%E6%96%B9%E6%B3%95/016-imageName%E5%92%8CimageWithContextOfFile%20%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/README/</url>
    <content><![CDATA[<blockquote>
<p>imageNamed性能高，因为他缓存到内存中了！</p>
</blockquote>
<ol>
<li>用imageNamed的方式加载时，图片使用完毕后缓存到内存中，内存消耗多，加载速度快。即使生成的对象被 autoReleasePool释放了，这份缓存也不释放，如果图像比较大，或者图像比较多，用这种方式会消耗很大的内存。imageNamed采用了缓存机制，如果缓存中已加载了图片，直接从缓存读就行了，每次就不用再去读文件了，效率会更高 </li>
<li>imageWithContextOfFile加载，图片是不会缓存的，加载速度慢。</li>
<li>大量使用imageNamed方式会在不需要缓存的地方额外增加开销CPU的时间。当应用程序需要加载一张比较大的图片并且使用一次性，那么其实是没有必要去缓存这个图片的，用imageWithContentsOfFile是最为经济的方式,这样不会因为UIImage元素较多情况下，CPU会被逐个分散在不必要缓存上浪费过多时间.</li>
</ol>
<p><strong>结论</strong></p>
<ul>
<li>如果图片较小,并且频繁使用的图片,使用imageName:来加载图片(按钮图片&#x2F;主页图片&#x2F;占位图)</li>
<li>如果图片较大,并且使用次数较少,使用 imageWithContentOfFile:来加载(相册&#x2F;版本新特性)</li>
</ul>
<h1 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h1><p>在iOS开发中，<code>imageNamed:</code> 和 <code>imageWithContentsOfFile:</code> 是两个常用的加载图片的方法。它们有不同的用途和性能特点。</p>
<h3 id="imageNamed"><a href="#imageNamed" class="headerlink" title="imageNamed:"></a><code>imageNamed:</code></h3><p><strong>用法：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">UIImage *image = [UIImage imageNamed:@&quot;example.png&quot;];</span><br></pre></td></tr></table></figure></div>

<p><strong>特点：</strong></p>
<ul>
<li><strong>缓存机制</strong>：<code>imageNamed:</code> 方法会缓存已经加载的图片。当再次请求相同名称的图片时，会直接从缓存中获取，而不是重新加载。这可以提高性能，尤其是在多次使用相同图片的情况下。</li>
<li><strong>适用于资源包中的图片</strong>：通常用于加载应用程序包中的图片资源。</li>
<li><strong>不需要提供文件路径</strong>：只需要提供图片名称，系统会自动在资源包中查找。</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li>适合加载应用程序包中的小图片。</li>
<li>适合频繁使用的图片，因为缓存机制可以提高性能。</li>
</ul>
<h3 id="imageWithContentsOfFile"><a href="#imageWithContentsOfFile" class="headerlink" title="imageWithContentsOfFile:"></a><code>imageWithContentsOfFile:</code></h3><p><strong>用法：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;example&quot; ofType:@&quot;png&quot;];</span><br><span class="line">UIImage *image = [UIImage imageWithContentsOfFile:filePath];</span><br></pre></td></tr></table></figure></div>

<p><strong>特点：</strong></p>
<ul>
<li><strong>无缓存机制</strong>：<code>imageWithContentsOfFile:</code> 每次调用都会从磁盘加载图片，不会缓存。这意味着在频繁使用同一图片时，性能可能会受到影响。</li>
<li><strong>需要提供完整路径</strong>：需要提供图片的完整文件路径。</li>
<li><strong>适用于沙盒中的图片</strong>：可以加载沙盒中的图片资源。</li>
</ul>
<p><strong>适用场景：</strong></p>
<ul>
<li>适合加载不经常使用的图片。</li>
<li>适合加载动态生成或下载到沙盒中的图片。</li>
</ul>
<h3 id="性能比较"><a href="#性能比较" class="headerlink" title="性能比较"></a>性能比较</h3><ul>
<li><strong>内存占用</strong>：由于<code>imageNamed:</code>会缓存图片，如果加载大量图片，可能会增加内存占用。而<code>imageWithContentsOfFile:</code>每次都从磁盘读取图片，内存占用较低，但会增加磁盘I&#x2F;O。</li>
<li><strong>加载速度</strong>：对于多次使用同一图片的情况，<code>imageNamed:</code>的性能更高，因为缓存机制避免了重复的磁盘I&#x2F;O。对于一次性加载的图片，<code>imageWithContentsOfFile:</code>可以避免不必要的内存缓存。</li>
<li><strong>适用场景</strong>：在需要频繁使用相同图片的场景下，<code>imageNamed:</code>更具优势。在只需要偶尔加载或一次性使用图片的场景下，<code>imageWithContentsOfFile:</code>更适合。</li>
</ul>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p><strong><code>imageNamed:</code> 示例</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">UIImage *image = [UIImage imageNamed:@&quot;example.png&quot;];</span><br></pre></td></tr></table></figure></div>

<p><strong><code>imageWithContentsOfFile:</code> 示例</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSString *filePath = [[NSBundle mainBundle] pathForResource:@&quot;example&quot; ofType:@&quot;png&quot;];</span><br><span class="line">UIImage *image = [UIImage imageWithContentsOfFile:filePath];</span><br></pre></td></tr></table></figure></div>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>**<code>imageNamed:</code>**：适合频繁使用的图片，具有缓存机制，加载速度快，内存占用相对较高。</li>
<li>**<code>imageWithContentsOfFile:</code>**：适合偶尔使用或动态加载的图片，无缓存机制，加载速度稍慢，但内存占用较低。</li>
</ul>
<p>选择哪个方法取决于具体的使用场景和性能需求。对于频繁使用的图片资源，建议使用<code>imageNamed:</code>；对于一次性加载或动态生成的图片资源，建议使用<code>imageWithContentsOfFile:</code>。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>imageName</tag>
      </tags>
  </entry>
  <entry>
    <title>View的layout的方法</title>
    <url>/2024/07/30/iOS/OC/003-OC%E6%96%B9%E6%B3%95/020-View%E7%9A%84layout%E7%9A%84%E6%96%B9%E6%B3%95/README/</url>
    <content><![CDATA[<p><a class="link"   href="https://www.jianshu.com/p/2ef48c2f0c97" >iOS 谈谈layoutSubviews何用 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<span id="more"></span>

<p>下面列出View的layout的方法:</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">layoutSubviews</span><br><span class="line">layoutIfNeeded</span><br><span class="line">setNeedsLayout</span><br><span class="line">setNeedsDisplay</span><br><span class="line">drawRect</span><br><span class="line">sizeThatFits</span><br><span class="line">sizeToFit</span><br></pre></td></tr></table></figure></div>

<h1 id="layoutSubviews"><a href="#layoutSubviews" class="headerlink" title="layoutSubviews"></a>layoutSubviews</h1><p><code>layoutSubviews</code> 是 <code>UIView</code> 的一个方法，用于在视图的子视图布局发生变化时进行重新布局。它的调用时机有以下几种情况：</p>
<h3 id="1-初始布局"><a href="#1-初始布局" class="headerlink" title="1. 初始布局"></a>1. 初始布局</h3><p>当视图第一次显示时，系统会自动调用 <code>layoutSubviews</code> 方法以布局视图及其子视图。</p>
<h3 id="2-布局发生变化"><a href="#2-布局发生变化" class="headerlink" title="2. 布局发生变化"></a>2. 布局发生变化</h3><p>当视图的 <code>frame</code> 或 <code>bounds</code> 改变时，系统会调用 <code>layoutSubviews</code> 方法。例如，通过设置视图的 <code>frame</code> 或 <code>bounds</code> 来改变视图的大小或位置时。</p>
<h3 id="3-子视图添加或移除"><a href="#3-子视图添加或移除" class="headerlink" title="3. 子视图添加或移除"></a>3. 子视图添加或移除</h3><p>当向视图中添加或移除子视图时，<code>layoutSubviews</code> 会被调用。例如，使用 <code>addSubview:</code> 或 <code>removeFromSuperview</code> 方法时。</p>
<h3 id="4-设置需要布局更新"><a href="#4-设置需要布局更新" class="headerlink" title="4. 设置需要布局更新"></a>4. 设置需要布局更新</h3><p>当调用 <code>setNeedsLayout</code> 方法时，系统会标记视图需要重新布局，并在下一个布局周期调用 <code>layoutSubviews</code> 方法。</p>
<h3 id="5-设置需要显示更新"><a href="#5-设置需要显示更新" class="headerlink" title="5. 设置需要显示更新"></a>5. 设置需要显示更新</h3><p>当调用 <code>setNeedsDisplay</code> 方法时，系统也会调用 <code>layoutSubviews</code> 方法，因为需要重新绘制视图。</p>
<h3 id="6-设备旋转"><a href="#6-设备旋转" class="headerlink" title="6. 设备旋转"></a>6. 设备旋转</h3><p>当设备旋转导致屏幕尺寸变化时，系统会调用 <code>layoutSubviews</code> 方法以适应新的屏幕尺寸。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><div class="highlight-container" data-rel="Swift"><figure class="iseeu highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomView</span>: <span class="title class_ inherited__">UIView</span> &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">layoutSubviews</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.layoutSubviews()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在此处调整子视图的布局</span></span><br><span class="line">        subview.frame <span class="operator">=</span> <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="keyword">self</span>.bounds.width, height: <span class="number">50</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这个示例中，每当 <code>CustomView</code> 的 <code>frame</code> 或 <code>bounds</code> 发生变化时，系统会调用 <code>layoutSubviews</code> 方法，在该方法中可以调整 <code>subview</code> 的 <code>frame</code> 以适应新的尺寸。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>layoutSubviews</code> 方法在视图的布局或子视图的布局需要更新时被调用。理解它的调用时机有助于在自定义视图时正确处理布局更新。</p>
<h1 id="layoutIfNeeded"><a href="#layoutIfNeeded" class="headerlink" title="layoutIfNeeded"></a>layoutIfNeeded</h1><p><code>layoutIfNeeded</code> 是 <code>UIView</code> 的一个方法，用于立即布局视图及其子视图。通常情况下，视图的布局会在下一个运行循环中异步执行，但是如果你希望立即执行布局而不等待下一个运行循环，可以调用 <code>layoutIfNeeded</code> 方法。</p>
<h3 id="调用时机"><a href="#调用时机" class="headerlink" title="调用时机"></a>调用时机</h3><ol>
<li><p><strong>手动布局更新</strong>：</p>
<ul>
<li>当你需要确保视图在某个时刻立即布局时，可以在需要的地方调用 <code>layoutIfNeeded</code> 方法。例如，在视图控制器的 <code>viewWillAppear</code> 或 <code>viewDidAppear</code> 方法中，有时需要确保视图已经正确布局后再执行某些操作。</li>
</ul>
</li>
<li><p><strong>动画布局</strong>：</p>
<ul>
<li>在使用 <code>UIView</code> 的动画方法（如 <code>animate(withDuration:animations:)</code>）时，你可以在动画代码块中使用 <code>layoutIfNeeded</code> 方法来确保动画执行过程中视图的布局是最新的。这可以避免动画执行过程中布局更新导致的不良效果。</li>
</ul>
</li>
<li><p><strong>获取布局后的尺寸</strong>：</p>
<ul>
<li>在某些情况下，你可能需要获取视图在特定时刻的布局后的尺寸或位置信息。在获取这些信息之前，可以调用 <code>layoutIfNeeded</code> 来确保已经进行了布局计算。</li>
</ul>
</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><div class="highlight-container" data-rel="Swift"><figure class="iseeu highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomView</span>: <span class="title class_ inherited__">UIView</span> &#123;</span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">animateAndLayout</span>() &#123;</span><br><span class="line">        <span class="type">UIView</span>.animate(withDuration: <span class="number">0.3</span>) &#123;</span><br><span class="line">            <span class="comment">// 在动画中更新约束或者属性</span></span><br><span class="line">            <span class="keyword">self</span>.layoutIfNeeded()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这个示例中，当 <code>animateAndLayout</code> 方法被调用时，通过 <code>UIView</code> 的动画方法来执行动画，同时在动画块中调用 <code>layoutIfNeeded</code> 方法，确保在动画执行期间视图的布局是最新的。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>layoutIfNeeded</code> 方法通常用于需要立即执行布局或确保在某些操作之前视图已经完成布局计算的情况下。它能够在需要时强制视图立即进行布局计算，并等待布局更新完成。</p>
<h1 id="setNeedsLayout"><a href="#setNeedsLayout" class="headerlink" title="setNeedsLayout"></a>setNeedsLayout</h1><p><code>setNeedsLayout</code> 是 <code>UIView</code> 的一个方法，用于标记视图需要重新布局。在标记之后，系统会在下一个布局周期中异步调用 <code>layoutSubviews</code> 方法。这个方法不会立即触发布局更新，但会在下一次运行循环中进行布局。调用 <code>setNeedsLayout</code> 的场景主要包括以下几种：</p>
<h3 id="调用时机-1"><a href="#调用时机-1" class="headerlink" title="调用时机"></a>调用时机</h3><ol>
<li><p><strong>视图的属性发生变化</strong>：</p>
<ul>
<li>当视图的某些属性（如 <code>frame</code>、<code>bounds</code>、<code>center</code> 等）发生变化时，你需要更新其子视图的布局。例如，如果你手动改变了视图的 <code>frame</code>，可以调用 <code>setNeedsLayout</code> 来确保子视图布局在下一个布局周期内更新。</li>
</ul>
</li>
<li><p><strong>视图的内容发生变化</strong>：</p>
<ul>
<li>如果视图的内容发生了变化，并且需要重新布局子视图。例如，视图中的文本、图像等内容变化后，需要调整子视图的位置或大小。</li>
</ul>
</li>
<li><p><strong>响应外部事件</strong>：</p>
<ul>
<li>当响应外部事件（如用户交互、通知等）需要更新视图的布局时。例如，用户点击按钮后需要调整其他视图的位置或大小。</li>
</ul>
</li>
<li><p><strong>约束变化</strong>：</p>
<ul>
<li>当使用 Auto Layout 并且视图的约束发生变化时，可以调用 <code>setNeedsLayout</code> 来触发重新布局。例如，你修改了视图的 NSLayoutConstraint 并希望立即生效。</li>
</ul>
</li>
</ol>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><div class="highlight-container" data-rel="Swift"><figure class="iseeu highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomView</span>: <span class="title class_ inherited__">UIView</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> someProperty: <span class="type">Int</span> <span class="operator">=</span> <span class="number">0</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="comment">// 当属性变化时，需要更新视图布局</span></span><br><span class="line">            setNeedsLayout()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">layoutSubviews</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.layoutSubviews()</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在此处调整子视图的布局</span></span><br><span class="line">        subview.frame <span class="operator">=</span> <span class="type">CGRect</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, width: <span class="keyword">self</span>.bounds.width, height: <span class="number">50</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这个示例中，当 <code>someProperty</code> 发生变化时，会调用 <code>setNeedsLayout</code> 方法，标记视图需要重新布局。然后在下一个布局周期中，系统会调用 <code>layoutSubviews</code> 方法，在该方法中可以调整子视图的布局。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><code>setNeedsLayout</code> 方法用于标记视图需要重新布局，在标记后，系统会在下一个布局周期内异步调用 <code>layoutSubviews</code> 方法。它通常用于响应视图属性、内容或外部事件的变化，以确保子视图的布局是最新的。通过调用 <code>setNeedsLayout</code>，可以延迟布局更新，从而优化性能和减少不必要的布局计算。</p>
<p><strong>setNeedsLayout方法并不会立即刷新，立即刷新需要调用layoutIfNeeded方法！</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">[self.view setNeedsLayout];</span><br><span class="line">[self.view layoutIfNeeded];</span><br></pre></td></tr></table></figure></div>



<h1 id="setNeedsDisplay"><a href="#setNeedsDisplay" class="headerlink" title="setNeedsDisplay"></a>setNeedsDisplay</h1><p><code>setNeedsDisplay</code> 是 <code>UIView</code> 的一个方法，用于标记视图需要重新绘制。调用 <code>setNeedsDisplay</code> 方法会使系统在下一个绘制周期中调用视图的 <code>draw(_:)</code> 方法。这通常用于视图内容发生变化，需要重新绘制的情况。以下是一些常见的调用场景：</p>
<h3 id="调用时机-2"><a href="#调用时机-2" class="headerlink" title="调用时机"></a>调用时机</h3><ol>
<li><p><strong>视图内容发生变化</strong>：</p>
<ul>
<li>当视图的内容需要更新时（例如文本、图像或颜色等变化），可以调用 <code>setNeedsDisplay</code> 来标记视图需要重新绘制。例如，你在自定义视图中绘制了一个图形，如果图形的数据发生了变化，需要调用 <code>setNeedsDisplay</code> 重新绘制。</li>
</ul>
</li>
<li><p><strong>视图的属性发生变化</strong>：</p>
<ul>
<li>如果视图的某些属性（如背景色、透明度等）发生变化，且这些变化需要通过重新绘制才能反映出来。例如，你改变了视图的 <code>backgroundColor</code> 或 <code>alpha</code> 值，可以调用 <code>setNeedsDisplay</code> 重新绘制视图。</li>
</ul>
</li>
<li><p><strong>响应外部事件</strong>：</p>
<ul>
<li>当响应外部事件（如用户交互、通知等）需要更新视图的内容时。例如，用户点击按钮后，需要更新视图中显示的内容。</li>
</ul>
</li>
<li><p><strong>动画效果</strong>：</p>
<ul>
<li>在某些动画效果中，需要逐帧更新视图的内容。例如，你在一个自定义视图中实现动画，通过定时器或 CADisplayLink 调用 <code>setNeedsDisplay</code> 来逐帧重绘视图。</li>
</ul>
</li>
</ol>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><div class="highlight-container" data-rel="Swift"><figure class="iseeu highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CustomView</span>: <span class="title class_ inherited__">UIView</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> fillColor: <span class="type">UIColor</span> <span class="operator">=</span> .red &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="comment">// 当填充颜色变化时，标记视图需要重新绘制</span></span><br><span class="line">            setNeedsDisplay()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">draw</span>(<span class="keyword">_</span> <span class="params">rect</span>: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.draw(rect)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 在此处执行自定义绘制</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> context <span class="operator">=</span> <span class="type">UIGraphicsGetCurrentContext</span>() <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        </span><br><span class="line">        context.setFillColor(fillColor.cgColor)</span><br><span class="line">        context.fill(rect)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在这个示例中，当 <code>fillColor</code> 属性变化时，会调用 <code>setNeedsDisplay</code> 方法，标记视图需要重新绘制。在下一个绘制周期中，系统会调用 <code>draw(_:)</code> 方法，在该方法中可以执行自定义绘制。</p>
<h3 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h3><p><code>setNeedsDisplay</code> 方法用于标记视图需要重新绘制，在标记后，系统会在下一个绘制周期内调用 <code>draw(_:)</code> 方法。它通常用于视图内容或属性发生变化，需要通过重新绘制来反映这些变化的情况。通过调用 <code>setNeedsDisplay</code>，可以确保视图内容及时更新，保持与应用状态的一致性。</p>
<h1 id="drawRect"><a href="#drawRect" class="headerlink" title="drawRect"></a>drawRect</h1><p>在iOS开发中，<code>drawRect:</code>方法是<code>UIView</code>类的一个实例方法，用于在自定义视图中绘制内容。<code>drawRect:</code>方法会在系统需要视图重绘时调用，比如视图首次显示或需要更新其内容时。以下是一些具体的场景：</p>
<h3 id="何时调用drawRect"><a href="#何时调用drawRect" class="headerlink" title="何时调用drawRect:"></a>何时调用<code>drawRect:</code></h3><ol>
<li><p><strong>视图首次显示</strong>：</p>
<ul>
<li>当视图首次显示在屏幕上时，系统会调用<code>drawRect:</code>方法来绘制视图的内容。</li>
</ul>
</li>
<li><p><strong>视图内容需要更新</strong>：</p>
<ul>
<li>当视图的内容发生变化，需要重新绘制时，系统会调用<code>drawRect:</code>方法。例如，调用<code>setNeedsDisplay</code>或<code>setNeedsDisplayInRect:</code>方法会标记视图为需要重绘，系统会在下一个绘制周期中调用<code>drawRect:</code>方法。</li>
</ul>
</li>
<li><p><strong>视图尺寸变化</strong>：</p>
<ul>
<li>当视图的尺寸发生变化时（例如，通过自动布局约束调整），系统可能会调用<code>drawRect:</code>方法以适应新的尺寸。</li>
</ul>
</li>
</ol>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是一个示例，演示如何在自定义视图中实现<code>drawRect:</code>方法：</p>
<div class="highlight-container" data-rel="Swift"><figure class="iseeu highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomView</span>: <span class="title class_ inherited__">UIView</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化方法</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">init</span>(<span class="params">frame</span>: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(frame: frame)</span><br><span class="line">        setup()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">required</span> <span class="keyword">init?</span>(<span class="params">coder</span>: <span class="type">NSCoder</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>.<span class="keyword">init</span>(coder: coder)</span><br><span class="line">        setup()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置初始配置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">func</span> <span class="title function_">setup</span>() &#123;</span><br><span class="line">        <span class="comment">// 可以在这里进行一些初始配置</span></span><br><span class="line">        backgroundColor <span class="operator">=</span> .white</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制内容</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">draw</span>(<span class="keyword">_</span> <span class="params">rect</span>: <span class="type">CGRect</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取绘图上下文</span></span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> context <span class="operator">=</span> <span class="type">UIGraphicsGetCurrentContext</span>() <span class="keyword">else</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置绘图属性</span></span><br><span class="line">        context.setLineWidth(<span class="number">2.0</span>)</span><br><span class="line">        context.setStrokeColor(<span class="type">UIColor</span>.red.cgColor)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 绘制矩形</span></span><br><span class="line">        <span class="keyword">let</span> rectangle <span class="operator">=</span> <span class="type">CGRect</span>(x: <span class="number">10</span>, y: <span class="number">10</span>, width: <span class="number">100</span>, height: <span class="number">100</span>)</span><br><span class="line">        context.addRect(rectangle)</span><br><span class="line">        context.strokePath()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="触发drawRect"><a href="#触发drawRect" class="headerlink" title="触发drawRect:"></a>触发<code>drawRect:</code></h3><p>你可以通过以下方式触发视图的重绘，进而调用<code>drawRect:</code>方法：</p>
<ol>
<li><p>**手动调用<code>setNeedsDisplay</code>**：</p>
<ul>
<li>标记整个视图为需要重绘。</li>
</ul>
 <div class="highlight-container" data-rel="Swift"><figure class="iseeu highlight swift"><table><tr><td class="code"><pre><span class="line">customView.setNeedsDisplay()</span><br></pre></td></tr></table></figure></div>
</li>
<li><p>**手动调用<code>setNeedsDisplayInRect:</code>**：</p>
<ul>
<li>标记视图的特定区域为需要重绘。</li>
</ul>
 <div class="highlight-container" data-rel="Swift"><figure class="iseeu highlight swift"><table><tr><td class="code"><pre><span class="line">customView.setNeedsDisplay(in: <span class="type">CGRect</span>(x: <span class="number">10</span>, y: <span class="number">10</span>, width: <span class="number">50</span>, height: <span class="number">50</span>))</span><br></pre></td></tr></table></figure></div></li>
</ol>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><code>drawRect:</code>方法只应在视图内容需要更新时调用，避免不必要的性能开销。</li>
<li>不要直接调用<code>drawRect:</code>方法。相反，使用<code>setNeedsDisplay</code>或<code>setNeedsDisplayInRect:</code>来触发重绘。</li>
<li>在<code>drawRect:</code>方法中进行绘制操作时，应避免执行耗时任务，以保持界面流畅。</li>
<li>如果你的视图不需要自定义绘制，避免重写<code>drawRect:</code>方法，因为它会禁用视图的离屏渲染优化。</li>
</ul>
<h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><code>drawRect:</code>方法是用于在自定义视图中绘制内容的关键方法。它会在视图首次显示、内容需要更新或尺寸变化时由系统调用。通过合理使用<code>setNeedsDisplay</code>和<code>setNeedsDisplayInRect:</code>方法，你可以控制视图的重绘行为，确保应用界面的高效和流畅。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>View</tag>
        <tag>layout</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS定时器</title>
    <url>/2024/07/30/iOS/OC/003-OC%E6%96%B9%E6%B3%95/019-%E5%AE%9A%E6%97%B6%E5%99%A8/README/</url>
    <content><![CDATA[<p>在 iOS 中，有多种方式可以实现定时器（Timer）功能，每种方式都有其适用的场景和特性。以下是几种常用的定时器实现方式：</p>
<h3 id="1-Timer"><a href="#1-Timer" class="headerlink" title="1. Timer"></a>1. <code>Timer</code></h3><p><code>Timer</code> 是 Foundation 框架中的一个类，用于创建和管理定时器。它可以在指定的时间间隔内重复调用某个方法或执行某个闭包。</p>
<h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><div class="highlight-container" data-rel="Swift"><figure class="iseeu highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TimerExample</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> timer: <span class="type">Timer</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">startTimer</span>() &#123;</span><br><span class="line">        timer <span class="operator">=</span> <span class="type">Timer</span>.scheduledTimer(timeInterval: <span class="number">1.0</span>, target: <span class="keyword">self</span>, selector: <span class="keyword">#selector</span>(timerFired), userInfo: <span class="literal">nil</span>, repeats: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">func</span> <span class="title function_">timerFired</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Timer fired!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">stopTimer</span>() &#123;</span><br><span class="line">        timer<span class="operator">?</span>.invalidate()</span><br><span class="line">        timer <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> example <span class="operator">=</span> <span class="type">TimerExample</span>()</span><br><span class="line">example.startTimer()</span><br></pre></td></tr></table></figure></div>

<h4 id="关键点"><a href="#关键点" class="headerlink" title="关键点"></a>关键点</h4><ul>
<li><code>scheduledTimer(timeInterval:target:selector:userInfo:repeats:)</code>：创建并启动一个定时器。</li>
<li><code>invalidate()</code>：停止定时器。</li>
<li>定时器默认运行在默认模式（<code>default</code>）下，如果需要在滚动等操作时继续运行，需要添加到运行循环中的不同模式（例如 <code>RunLoop.Mode.common</code>）。</li>
</ul>
<h3 id="2-CADisplayLink"><a href="#2-CADisplayLink" class="headerlink" title="2. CADisplayLink"></a>2. <code>CADisplayLink</code></h3><p><code>CADisplayLink</code> 是 Core Animation 框架中的一个类，它允许你在屏幕刷新时执行某个方法，通常用于动画的逐帧更新。</p>
<h4 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h4><div class="highlight-container" data-rel="Swift"><figure class="iseeu highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DisplayLinkExample</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> displayLink: <span class="type">CADisplayLink</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">startDisplayLink</span>() &#123;</span><br><span class="line">        displayLink <span class="operator">=</span> <span class="type">CADisplayLink</span>(target: <span class="keyword">self</span>, selector: <span class="keyword">#selector</span>(displayLinkFired))</span><br><span class="line">        displayLink<span class="operator">?</span>.add(to: .main, forMode: .default)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">func</span> <span class="title function_">displayLinkFired</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;DisplayLink fired!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">stopDisplayLink</span>() &#123;</span><br><span class="line">        displayLink<span class="operator">?</span>.invalidate()</span><br><span class="line">        displayLink <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> example <span class="operator">=</span> <span class="type">DisplayLinkExample</span>()</span><br><span class="line">example.startDisplayLink()</span><br></pre></td></tr></table></figure></div>

<h4 id="关键点-1"><a href="#关键点-1" class="headerlink" title="关键点"></a>关键点</h4><ul>
<li><code>CADisplayLink</code>：与屏幕刷新率同步，非常适合用于动画。</li>
<li><code>add(to:forMode:)</code>：将 <code>CADisplayLink</code> 添加到运行循环。</li>
</ul>
<h3 id="3-DispatchSourceTimer"><a href="#3-DispatchSourceTimer" class="headerlink" title="3. DispatchSourceTimer"></a>3. <code>DispatchSourceTimer</code></h3><p><code>DispatchSourceTimer</code> 是 GCD（Grand Central Dispatch）中的一个类，提供了一个更低级别的、基于块的定时器。</p>
<h4 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h4><div class="highlight-container" data-rel="Swift"><figure class="iseeu highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Dispatch</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GCDTimerExample</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> timer: <span class="type">DispatchSourceTimer</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">startTimer</span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">DispatchQueue</span>(label: <span class="string">&quot;com.example.timer&quot;</span>)</span><br><span class="line">        timer <span class="operator">=</span> <span class="type">DispatchSource</span>.makeTimerSource(queue: queue)</span><br><span class="line">        timer<span class="operator">?</span>.schedule(deadline: .now(), repeating: <span class="number">1.0</span>)</span><br><span class="line">        timer<span class="operator">?</span>.setEventHandler &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;GCD Timer fired!&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        timer<span class="operator">?</span>.resume()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">stopTimer</span>() &#123;</span><br><span class="line">        timer<span class="operator">?</span>.cancel()</span><br><span class="line">        timer <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> example <span class="operator">=</span> <span class="type">GCDTimerExample</span>()</span><br><span class="line">example.startTimer()</span><br></pre></td></tr></table></figure></div>

<h4 id="关键点-2"><a href="#关键点-2" class="headerlink" title="关键点"></a>关键点</h4><ul>
<li><code>DispatchSourceTimer</code>：提供了一个非常灵活和高效的定时器解决方案。</li>
<li><code>schedule(deadline:repeating:)</code>：配置定时器的启动时间和重复间隔。</li>
<li><code>setEventHandler(handler:)</code>：设置定时器触发时执行的代码块。</li>
<li><code>resume()</code>：启动定时器。</li>
</ul>
<h3 id="4-NSTimer（旧版-Timer）"><a href="#4-NSTimer（旧版-Timer）" class="headerlink" title="4. NSTimer（旧版 Timer）"></a>4. <code>NSTimer</code>（旧版 <code>Timer</code>）</h3><p><code>NSTimer</code> 是 <code>Timer</code> 的旧版名称，在现代 Swift 代码中通常使用 <code>Timer</code> 作为替代。</p>
<h4 id="使用示例-3"><a href="#使用示例-3" class="headerlink" title="使用示例"></a>使用示例</h4><div class="highlight-container" data-rel="Swift"><figure class="iseeu highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NSTimerExample</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> timer: <span class="type">NSTimer</span>?</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">startTimer</span>() &#123;</span><br><span class="line">        timer <span class="operator">=</span> <span class="type">NSTimer</span>.scheduledTimerWithTimeInterval(<span class="number">1.0</span>, target: <span class="keyword">self</span>, selector: <span class="keyword">#selector</span>(timerFired), userInfo: <span class="literal">nil</span>, repeats: <span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">@objc</span> <span class="keyword">func</span> <span class="title function_">timerFired</span>() &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;NSTimer fired!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">func</span> <span class="title function_">stopTimer</span>() &#123;</span><br><span class="line">        timer<span class="operator">?</span>.invalidate()</span><br><span class="line">        timer <span class="operator">=</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> example <span class="operator">=</span> <span class="type">NSTimerExample</span>()</span><br><span class="line">example.startTimer()</span><br></pre></td></tr></table></figure></div>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>**<code>Timer</code>**：适合大多数定时任务，易于使用。</li>
<li>**<code>CADisplayLink</code>**：适合需要与屏幕刷新率同步的任务，如动画。</li>
<li>**<code>DispatchSourceTimer</code>**：适合需要高性能和高灵活性的场景。</li>
<li>**<code>NSTimer</code>**：现代代码中通常使用 <code>Timer</code> 代替。</li>
</ul>
<p>根据具体需求选择合适的定时器工具，可以更好地满足应用的性能和功能要求。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>定时器</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS后台定时器</title>
    <url>/2024/07/30/iOS/OC/003-OC%E6%96%B9%E6%B3%95/019-%E5%AE%9A%E6%97%B6%E5%99%A8/%E5%90%8E%E5%8F%B0%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<p>方法一：根据记录开始的时间和获取当前时间进行时间差操作进行处理。监听进入前台、进入后台的消息，在进入后台的时候存一下时间戳，停掉定时器(系统会强制停止定时器)；在再进入前台时，计算时间差。若剩余的时间大于时间差，就减去时间差，否则赋值剩余时间为0。（主流）</p>
<p>方法二：苹果只允许三种情况下的App在后台可以一直执行：音视频、定位更新、下载，若是直播、视频播放、地图类、有下载的应用可以这样使用，但是有些小需求就不需这样做。</p>
<p>方法三：通过向苹果的系统申请，在后台完成一个Task任务。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>定时器</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS定时器循环引用问题</title>
    <url>/2024/07/30/iOS/OC/003-OC%E6%96%B9%E6%B3%95/019-%E5%AE%9A%E6%97%B6%E5%99%A8/%E5%AE%9A%E6%97%B6%E5%99%A8%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>循环引用</p>
<p><a class="link"   href="https://juejin.cn/post/6937926586167459870" >https://juejin.cn/post/6937926586167459870 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>定时器</tag>
        <tag>循环引用</tag>
      </tags>
  </entry>
  <entry>
    <title>Controller的生命周期</title>
    <url>/2024/08/07/iOS/OC/003-OC%E6%96%B9%E6%B3%95/022-Controller%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/Controller%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h2 id="UIViewController的生命周期及iOS程序执行顺序"><a href="#UIViewController的生命周期及iOS程序执行顺序" class="headerlink" title="UIViewController的生命周期及iOS程序执行顺序"></a>UIViewController的生命周期及iOS程序执行顺序</h2><ul>
<li><p><strong>当一个视图控制器被创建，并在屏幕上显示的时候。 代码的执行顺序</strong><br>1、alloc 创建对象，分配空间<br>2、init (initWithNibName) 初始化对象，初始化数据<br>3、loadView从nib载入视图，通常这一步不需要去干涉。除非你没有使用xib文件创建视图<br>4、viewDidLoad载入完成，可以进行自定义数据以及动态创建其他控件<br>5、viewWillAppear视图将出现在屏幕之前，马上这个视图就会被展现在屏幕上了<br>6、viewDidAppear视图已在屏幕上渲染完成</p>
</li>
<li><p><strong>当一个视图被移除屏幕并且销毁的时候的执行顺序，这个顺序差不多和上面的相反</strong><br>1、viewWillDisappear视图将被从屏幕上移除之前执行<br>2、viewDidDisappear视图已经被从屏幕上移除，用户看不到这个视图了<br>3、dealloc视图被销毁，此处需要对你在init和viewDidLoad中创建的对象进行释放</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>Controller</tag>
      </tags>
  </entry>
  <entry>
    <title>loadView介绍</title>
    <url>/2024/07/30/iOS/OC/003-OC%E6%96%B9%E6%B3%95/022-Controller%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/loadView%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>在iOS开发中，<code>loadView</code>是<code>UIViewController</code>类的一个生命周期方法，它负责加载或创建视图控制器的根视图。当视图控制器的视图属性被访问，但视图尚未加载时，系统会调用<code>loadView</code>方法。</p>
<span id="more"></span>

<h3 id="loadView的调用时机"><a href="#loadView的调用时机" class="headerlink" title="loadView的调用时机"></a><code>loadView</code>的调用时机</h3><p><code>loadView</code>方法在以下情况下会被调用：</p>
<ol>
<li><p><strong>访问视图控制器的<code>view</code>属性</strong>：当视图控制器的<code>view</code>属性首次被访问时，如果视图还没有被加载，系统会调用<code>loadView</code>方法来加载或创建视图。</p>
</li>
<li><p><strong>系统需要加载视图</strong>：在视图控制器的生命周期过程中，如果视图尚未加载但需要显示，系统会调用<code>loadView</code>方法。</p>
</li>
</ol>
<h3 id="loadView的作用"><a href="#loadView的作用" class="headerlink" title="loadView的作用"></a><code>loadView</code>的作用</h3><p><code>loadView</code>方法的主要作用是加载或创建视图控制器的根视图。默认情况下，<code>UIViewController</code>会从一个名为与视图控制器相同名称的<code>xib</code>文件或故事板中加载视图。如果没有关联的<code>xib</code>文件或故事板，系统会创建一个空的<code>UIView</code>实例作为根视图。</p>
<h3 id="自定义loadView"><a href="#自定义loadView" class="headerlink" title="自定义loadView"></a>自定义<code>loadView</code></h3><p>通常不需要重写<code>loadView</code>方法，而是通过故事板或<code>xib</code>文件来配置视图控制器的视图。但是，如果你需要完全以编程方式创建视图，可以重写<code>loadView</code>方法。</p>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>以下是一个自定义<code>loadView</code>方法的示例：</p>
<div class="highlight-container" data-rel="Swift"><figure class="iseeu highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> UIKit</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomViewController</span>: <span class="title class_ inherited__">UIViewController</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">loadView</span>() &#123;</span><br><span class="line">        <span class="comment">// 创建一个自定义的根视图</span></span><br><span class="line">        <span class="keyword">let</span> customView <span class="operator">=</span> <span class="type">UIView</span>()</span><br><span class="line">        customView.backgroundColor <span class="operator">=</span> .white</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 添加子视图</span></span><br><span class="line">        <span class="keyword">let</span> label <span class="operator">=</span> <span class="type">UILabel</span>()</span><br><span class="line">        label.text <span class="operator">=</span> <span class="string">&quot;Hello, World!&quot;</span></span><br><span class="line">        label.textAlignment <span class="operator">=</span> .center</span><br><span class="line">        label.translatesAutoresizingMaskIntoConstraints <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line">        customView.addSubview(label)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置约束</span></span><br><span class="line">        <span class="type">NSLayoutConstraint</span>.activate([</span><br><span class="line">            label.centerXAnchor.constraint(equalTo: customView.centerXAnchor),</span><br><span class="line">            label.centerYAnchor.constraint(equalTo: customView.centerYAnchor)</span><br><span class="line">        ])</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 将自定义视图设置为视图控制器的根视图</span></span><br><span class="line">        <span class="keyword">self</span>.view <span class="operator">=</span> customView</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">func</span> <span class="title function_">viewDidLoad</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line">        <span class="comment">// 其他初始化代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="loadView与其他生命周期方法的关系"><a href="#loadView与其他生命周期方法的关系" class="headerlink" title="loadView与其他生命周期方法的关系"></a><code>loadView</code>与其他生命周期方法的关系</h3><ul>
<li><code>loadView</code>：负责创建视图控制器的根视图。只有当视图控制器的视图尚未加载且<code>view</code>属性被访问时才会被调用。</li>
<li><code>viewDidLoad</code>：在视图控制器的视图已经加载完成后被调用。通常在这里进行视图的额外设置或初始化工作。</li>
<li><code>viewWillAppear</code>：在视图即将显示在屏幕上时被调用。</li>
<li><code>viewDidAppear</code>：在视图已经显示在屏幕上时被调用。</li>
<li><code>viewWillDisappear</code>：在视图即将从屏幕上消失时被调用。</li>
<li><code>viewDidDisappear</code>：在视图已经从屏幕上消失时被调用。</li>
</ul>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li><strong>不要直接调用</strong><code>loadView</code>：<code>loadView</code>方法由系统调用，不应在代码中直接调用。如果需要强制加载视图，可以通过访问<code>view</code>属性来触发。</li>
<li><strong>不要调用</strong><code>super.loadView()</code>：如果重写<code>loadView</code>方法，不要调用<code>super.loadView()</code>，因为默认实现会从<code>xib</code>文件或故事板加载视图。如果你是完全以编程方式创建视图，这一步是没有必要的。</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>loadView</code>方法在视图控制器的视图属性首次被访问时由系统调用，用于加载或创建根视图。通常通过故事板或<code>xib</code>文件配置视图，但在某些情况下可以通过重写<code>loadView</code>方法以编程方式创建自定义视图。合理使用<code>loadView</code>方法和其他生命周期方法，可以确保视图控制器的视图正确初始化和显示。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>loadView</tag>
      </tags>
  </entry>
  <entry>
    <title>static与extern</title>
    <url>/2024/07/30/iOS/OC/003-OC%E6%96%B9%E6%B3%95/024-static%E4%B8%8Eextern/README/</url>
    <content><![CDATA[<p>static 和 extern 是两个不同的关键字，在 iOS 中它们有着不同的作用：</p>
<span id="more"></span>

<h1 id="static"><a href="#static" class="headerlink" title="static"></a>static</h1><ul>
<li>static 关键字用于修饰变量、函数或块，以限定其作用域。</li>
<li>在函数内部，static 变量的生命周期将延长到整个程序的生命周期，而不是函数调用结束后销毁。</li>
<li>在文件内部，static 函数或变量只能在该文件内部访问，不能被其他文件访问。</li>
<li>在类内部，static 变量或函数属于类的静态成员，而不是实例成员。</li>
</ul>
<p>示例：</p>
<div class="highlight-container" data-rel="Objc"><figure class="iseeu highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在文件内部定义静态变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在函数内部定义静态变量</span></span><br><span class="line"><span class="type">void</span> foo() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">    x++;</span><br><span class="line">    printf(<span class="string">&quot;%d\n&quot;</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在类内部定义静态变量</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> classCounter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></div>


<h1 id="extern"><a href="#extern" class="headerlink" title="extern"></a>extern</h1><p>extern 关键字用于声明变量或函数的外部链接性，即该变量或函数可以被其他文件访问。<br>使用 extern 声明的变量或函数必须在其他文件中定义。<br>extern 可以用于导入其他文件中的变量或函数，以便在当前文件中使用。<br>示例：</p>
<div class="highlight-container" data-rel="Objc"><figure class="iseeu highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在头文件中声明外部变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> globalCounter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在实现文件中定义外部变量</span></span><br><span class="line"><span class="type">int</span> globalCounter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在头文件中声明外部函数</span></span><br><span class="line"><span class="keyword">extern</span> <span class="type">void</span> foo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在实现文件中定义外部函数</span></span><br><span class="line"><span class="type">void</span> foo() &#123;</span><br><span class="line">    printf(<span class="string">&quot;Hello, world!\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="static-extern："><a href="#static-extern：" class="headerlink" title="static extern："></a>static extern：</h1><p>static extern 是一个组合关键字，它的作用是将变量或函数同时声明为静态的和外部可访问的。<br>使用 static extern 声明的变量或函数只能在当前文件内部访问，但可以被其他文件通过外部链接访问。<br>示例：</p>
<div class="highlight-container" data-rel="Objc"><figure class="iseeu highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在头文件中声明静态外部变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">extern</span> <span class="type">int</span> fileCounter;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在实现文件中定义静态外部变量</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> fileCounter = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></div>
<p>需要注意的是，static extern 的使用场景非常少见，因为它限制了变量或函数的访问范围，同时又需要外部链接性。通常情况下，可以使用 extern 或 static 单独来声明变量或函数。</p>
<h1 id="自己的理解"><a href="#自己的理解" class="headerlink" title="自己的理解"></a>自己的理解</h1><p>（1）extern修饰的全局变量默认是有外部链接的，作用域是整个工程，在一个文件内定义的全局变量，在另一个文件中，通过extern全局变量的声明，就可以使用全局变量。</p>
<p>（2）static修饰全局变量，全局变量的作用域仅限于当前文件；</p>
<p>（3）static修饰局部变量，让局部变量只初始化一次，局部变量在程序中只有一份内存，并不会改变局部变量的作用域，仅仅是改变了局部变量的生命周期（只到程序结束，这个局部变量才会销毁）。</p>
<div class="highlight-container" data-rel="Objc"><figure class="iseeu highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> test() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;a = %d&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> main(<span class="type">int</span> argc, <span class="keyword">const</span> <span class="type">char</span> * argv[]) &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">           test();</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出 1 2 3</span></span><br></pre></td></tr></table></figure></div>


<h1 id="项目中使用"><a href="#项目中使用" class="headerlink" title="项目中使用"></a>项目中使用</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// .h</span><br><span class="line">extern NSString *const RCKitDispatchDownloadMediaNotification;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// .m</span><br><span class="line">NSString *const RCKitDispatchDownloadMediaNotification = @&quot;RCKitDispatchDownloadMediaNotification&quot;;</span><br></pre></td></tr></table></figure></div>

]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>static</tag>
        <tag>extern</tag>
      </tags>
  </entry>
  <entry>
    <title>判断两个NSString对象的字面量是否相同</title>
    <url>/2024/07/30/iOS/OC/003-OC%E6%96%B9%E6%B3%95/025-NSString/%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AANSString%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C/</url>
    <content><![CDATA[<p>判断两个NSString的字面量是否相同，为什么要用isEqualToString来判断，而不能用&#x3D;&#x3D;或isEqual来判断呢？</p>
<span id="more"></span>

<p>判断两个 NSString 对象的字面量是否相同，使用 isEqualToString: 方法是因为它专门用于比较字符串的字面量，而不是比较对象的地址或其他特征。</p>
<p>使用 &#x3D;&#x3D; 运算符来判断两个字符串对象的字面量是否相同是不可靠的，因为 &#x3D;&#x3D; 只比较两个对象的地址是否相同，而不是比较它们的字面量。例如：</p>
<div class="highlight-container" data-rel="Objc"><figure class="iseeu highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *str1 = <span class="string">@&quot;Hello&quot;</span>;</span><br><span class="line"><span class="built_in">NSString</span> *str2 = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;Hello&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (str1 == str2) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;The strings are equal&quot;</span>); <span class="comment">// 这里不会打印，因为str1和str2是不同的对象</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;The strings are not equal&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p>在上面的例子中，str1 和 str2 的字面量都是 “Hello”，但它们是不同的对象，因此 &#x3D;&#x3D; 运算符返回 NO。</p>
<p>使用 isEqual: 方法也不是一个好选择，因为它比较两个对象的等价性，而不是专门比较字符串的字面量。例如：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSString *str1 = @&quot;Hello&quot;;</span><br><span class="line">NSMutableString *str2 = [NSMutableString stringWithString:@&quot;Hello&quot;];</span><br><span class="line"></span><br><span class="line">if ([str1 isEqual:str2]) &#123;</span><br><span class="line">    NSLog(@&quot;The strings are equal&quot;); // 这里会打印，因为str1和str2的字面量相同</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    NSLog(@&quot;The strings are not equal&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>在上面的例子中，str1 和 str2 的字面量都是 “Hello”，因此 isEqual: 方法返回 YES。但是，如果你想比较两个字符串对象的字面量是否相同，而不考虑它们的类别或其他特征，那么使用 isEqualToString: 方法是最好的选择。</p>
<p>isEqualToString: 方法专门用于比较两个字符串对象的字面量，它不考虑对象的地址或类别，只比较它们的字面量。例如：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSString *str1 = @&quot;Hello&quot;;</span><br><span class="line">NSString *str2 = [NSString stringWithFormat:@&quot;Hello&quot;];</span><br><span class="line"></span><br><span class="line">if ([str1 isEqualToString:str2]) &#123;</span><br><span class="line">    NSLog(@&quot;The strings are equal&quot;); // 这里会打印，因为str1和str2的字面量相同</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    NSLog(@&quot;The strings are not equal&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
<p>因此，在判断两个 NSString 对象的字面量是否相同时，使用 isEqualToString: 方法是最安全和可靠的选择。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>NSString</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS中float四舍五入+末尾清零</title>
    <url>/2024/08/08/iOS/OC/003-OC%E6%96%B9%E6%B3%95/027-iOS%E4%B8%ADfloat%E5%9B%9B%E8%88%8D%E4%BA%94%E5%85%A5+%E6%9C%AB%E5%B0%BE%E6%B8%85%E9%9B%B6/README/</url>
    <content><![CDATA[<h3 id="一、准备"><a href="#一、准备" class="headerlink" title="一、准备"></a>一、准备</h3><p>测试数据</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">float A = 0.124000;</span><br><span class="line">float B = 0.124200;</span><br><span class="line">float C = 0.125000;   （重点关注）</span><br><span class="line">float D = 0.125001;</span><br><span class="line">float E = 0.126000;</span><br></pre></td></tr></table></figure></div>
<p>目的：float保留两位小数显示，四舍五入。</p>
<h3 id="二、几种尝试"><a href="#二、几种尝试" class="headerlink" title="二、几种尝试"></a>二、几种尝试</h3><h4 id="2-1、最简单的方法"><a href="#2-1、最简单的方法" class="headerlink" title="2.1、最简单的方法"></a>2.1、最简单的方法</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSString * showA = [NSString stringWithFormat:@&quot;%0.2f&quot;,X];</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">A = 0.124000;  --&gt;  A = 0.12 </span><br><span class="line">B = 0.124200;  --&gt;  B = 0.12 </span><br><span class="line">C = 0.125000;  --&gt;  C = 0.12</span><br><span class="line">D = 0.125001;  --&gt;  D = 0.13</span><br><span class="line">E = 0.126000;  --&gt;  E = 0.13</span><br></pre></td></tr></table></figure></div>
<p>结果出现了一些偏差。也就是 <code>float C = 0.125000</code> 的情况。</p>
<h4 id="2-2、NSDecimalNumber"><a href="#2-2、NSDecimalNumber" class="headerlink" title="2.2、NSDecimalNumber"></a>2.2、NSDecimalNumber</h4><ul>
<li>进一步探讨，可查看<br><a class="link"   href="https://www.jianshu.com/p/946c4c4aff33" >iOS 浮点数的精确计算和四舍五入问题 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">枚举</span><br><span class="line">    NSRoundPlain,   // Round up on a tie   貌似取整</span><br><span class="line">    NSRoundDown,    // Always down == truncate   只舍不入</span><br><span class="line">    NSRoundUp,      // Always up     只入不舍</span><br><span class="line">    NSRoundBankers  // on a tie round so last digit is even   貌似四舍五入</span><br><span class="line">*/</span><br><span class="line">NSDecimalNumberHandler* roundingBehavior = [NSDecimalNumberHandler decimalNumberHandlerWithRoundingMode:NSRoundBankers</span><br><span class="line">scale:2</span><br><span class="line">                                                                                       raiseOnExactness:NO</span><br><span class="line">                                                                                        raiseOnOverflow:NO</span><br><span class="line">                                                                                       raiseOnUnderflow:NO</span><br><span class="line">                                                                                    raiseOnDivideByZero:YES];</span><br><span class="line">NSDecimalNumber * ouncesDecimal = [[NSDecimalNumber alloc] initWithFloat:X];</span><br><span class="line">NSDecimalNumber * roundedOunces = [ouncesDecimal decimalNumberByRoundingAccordingToBehavior:roundingBehavior];</span><br><span class="line">NSString * showX = [NSString stringWithFormat:@&quot;%@&quot;,roundedOunces];</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">A = 0.124000;  --&gt;  A = 0.12 </span><br><span class="line">B = 0.124200;  --&gt;  B = 0.12 </span><br><span class="line">C = 0.125000;  --&gt;  C = 0.12    （重点关注）</span><br><span class="line">C1 = 0.135000; --&gt;  C = 0.14    （重点关注）</span><br><span class="line">D = 0.125001;  --&gt;  D = 0.13</span><br><span class="line">E = 0.126000;  --&gt;  E = 0.13</span><br></pre></td></tr></table></figure></div>

<p>结果同上， <code>float C = 0.125000</code> 的情况还不行。</p>
<blockquote>
<p><code>NSRoundPlain</code> 和 <code>NSRoundBankers</code> 都不是传统的四舍五入。<br>1、<code>NSRoundPlain</code> 是四舍六进若五前偶数进位奇数舍去。如：1.25 ~ 1.3；1.15 ~ 1.1<br>2、<code>NSRoundBankers</code> 是四舍六进若五前偶数舍去奇数进位。如：1.25 ~ 1.2；1.15 ~ 1.2</p>
</blockquote>
<h4 id="2-3、roundf"><a href="#2-3、roundf" class="headerlink" title="2.3、roundf()"></a>2.3、roundf()</h4><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSString * showX = [NSString stringWithFormat:@&quot;%0.2f&quot;,roundf(X * 100)/100];</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">A = 0.124000;  --&gt;  A = 0.12 </span><br><span class="line">B = 0.124200;  --&gt;  B = 0.12 </span><br><span class="line">C = 0.125000;  --&gt;  C = 0.13</span><br><span class="line">D = 0.125001;  --&gt;  D = 0.13</span><br><span class="line">E = 0.126000;  --&gt;  E = 0.13</span><br></pre></td></tr></table></figure></div>

<p>发现这个方法好像更靠谱点。</p>
<p><strong>拓展的相关的其他函数</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">round  如果参数是小数  则求本身的四舍五入.</span><br><span class="line">ceil   如果参数是小数  则求最小的整数但不小于本身.</span><br><span class="line">floor  如果参数是小数  则求最大的整数但不大于本身. </span><br></pre></td></tr></table></figure></div>


<h3 id="三、尾部清零"><a href="#三、尾部清零" class="headerlink" title="三、尾部清零"></a>三、尾部清零</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSString * floatnum = @&quot;0.125000&quot;</span><br><span class="line">NSString * outNumber1 = [NSString stringWithFormat:@&quot;%@&quot;,@(floatnum.floatValue)];</span><br></pre></td></tr></table></figure></div>

<h3 id="四、项目需求：保留2位小数（四舍五入），末尾如果是零，则不要。"><a href="#四、项目需求：保留2位小数（四舍五入），末尾如果是零，则不要。" class="headerlink" title="四、项目需求：保留2位小数（四舍五入），末尾如果是零，则不要。"></a>四、项目需求：保留2位小数（四舍五入），末尾如果是零，则不要。</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ (NSString *)FloatKeepTwoBitsAndRemoveAllZero:(float)floatnum &#123;</span><br><span class="line">    // 保留2位小数</span><br><span class="line">    NSString * tempfloat = [NSString stringWithFormat:@&quot;%0.2f&quot;,roundf(floatnum * 100)/100];</span><br><span class="line">    // 末尾清零</span><br><span class="line">    return [NSString stringWithFormat:@&quot;%@&quot;,@(tempfloat.floatValue)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS随机数生成</title>
    <url>/2024/08/08/iOS/OC/003-OC%E6%96%B9%E6%B3%95/026-iOS%E9%9A%8F%E6%9C%BA%E6%95%B0/README/</url>
    <content><![CDATA[<h1 id="一、26个字母随机生成32位字符串"><a href="#一、26个字母随机生成32位字符串" class="headerlink" title="一、26个字母随机生成32位字符串"></a>一、26个字母随机生成32位字符串</h1><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 此方法随机产生32位字符串， 修改代码红色数字可以改变 随机产生的位数。</span><br><span class="line">+(NSString *)ret32bitString</span><br><span class="line">&#123;</span><br><span class="line">    char data[32];</span><br><span class="line">    for (int x=0;x&lt;32;data[x++] = (char)(&#x27;A&#x27; + (arc4random_uniform(26))));</span><br><span class="line">    return [[NSStringalloc] initWithBytes:data length:32 encoding:NSUTF8StringEncoding];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h1 id="二、产生随机数"><a href="#二、产生随机数" class="headerlink" title="二、产生随机数"></a>二、产生随机数</h1><ul>
<li>获取一个随机整数范围在：[0,100)包括0，不包括100<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">int x = arc4random() % 100;</span><br></pre></td></tr></table></figure></div></li>
<li>获取一个随机数范围在：[500,1000），包括500，不包括1000<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">int y = (arc4random() % 501) + 500;</span><br></pre></td></tr></table></figure></div></li>
<li>获取一个随机整数，范围在[from,to），包括from，不包括to<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">-(int)getRandomNumber:(int)from to:(int)to</span><br><span class="line">&#123;</span><br><span class="line">    return (int)(from + (arc4random() % (to – from +1)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></li>
</ul>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS中浮点数精度丢失</title>
    <url>/2024/08/08/iOS/OC/003-OC%E6%96%B9%E6%B3%95/028-%E6%B5%AE%E7%82%B9%E6%95%B0%E7%B2%BE%E5%BA%A6%E4%B8%A2%E5%A4%B1/README/</url>
    <content><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a class="link"   href="https://blog.csdn.net/yangxiaohei1234/article/details/77870749" >深入浅出iOS浮点数精度问题 (上) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://blog.csdn.net/txz_gray/article/details/53303918" >iOS 关于网络数据解析小数位精度丢失问题的修正 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://www.jianshu.com/p/83d4bc28cc7c" >iOS - Json解析精度丢失处理(NSString, Double, Float) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p><a class="link"   href="https://blog.csdn.net/wangyanchang21/article/details/71036031" >124.浮点型数据精度不准确的探究 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="一、引入"><a href="#一、引入" class="headerlink" title="一、引入"></a>一、引入</h2><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">double firstD = 11111.7;</span><br><span class="line">double secondD = 22222.6;</span><br><span class="line"></span><br><span class="line">NSString * firstDStr = [NSString stringWithFormat:@&quot;%0.2f&quot;,firstD];</span><br><span class="line">NSString * secondDStr = [NSString stringWithFormat:@&quot;%0.2f&quot;,secondD];</span><br><span class="line"></span><br><span class="line">LXLog(@&quot;EE = %@ == %@&quot;,firstDStr,secondDStr);</span><br><span class="line"></span><br><span class="line">double f = [firstDStr doubleValue];</span><br><span class="line">double s = [secondDStr doubleValue];</span><br><span class="line"></span><br><span class="line">LXLog(@&quot;FF = %f == %f&quot;,f,s);</span><br><span class="line"></span><br><span class="line">LXLog(@&quot;GG = %.12f == %.12f&quot;,f,s);</span><br></pre></td></tr></table></figure></div>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">************** Log *****************</span><br><span class="line">EE = 11111.70 == 22222.60</span><br><span class="line">FF = 11111.700000 == 22222.600000</span><br><span class="line">GG = 11111.700000000001 == 22222.599999999999</span><br></pre></td></tr></table></figure></div>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>第一步：保留两位小数字符串，是正确的！！<br>第二步：<code>字符串@&quot;11111.70&quot;</code>转换为<code>浮点数</code>，却多了几位小数。因为 C 语言中，格式化字符串默认 “%f” 默认保留到小数点后第6位。<br>第三步：通过限制小数点保留具体位数，可以看到浮点数真是面目。</p>
<h2 id="二、查看内部存储"><a href="#二、查看内部存储" class="headerlink" title="二、查看内部存储"></a>二、查看内部存储</h2><p><a class="link"   href="https://www.jianshu.com/p/d3e3eaa62731" >计算机字符编码系统（ASCII，Unicode和UTF）梳理 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://www.jianshu.com/p/046c3557f3e4" >编码:隐匿在计算机软硬件背后的语言 笔记 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://www.jianshu.com/p/da7cc80237f8" >简单理解编码 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://www.jianshu.com/p/92f6d4294504" >“unicode” 和 “utf-8” <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://mp.weixin.qq.com/s?__biz=MzIxOTI1NTk5Nw==&mid=2650047044&idx=1&sn=92c6a3472baaa70fa542a47c60f76b5d#rd" >计算机程序的思维逻辑 (6) - 如何从乱码中恢复 (上)？ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>在计算机内部，所有数据类型均是以二进制的方式存储。</p>
<p>二进制数的每一个位表示一个计算机位（bit，简称位），8个位组成一个字节(byte)。那么一个字节可以表示256种含义（2^8&#x3D;256）。 </p>
<p>虽然机器是基于二进制的，但对人类来说，因为二进制数太长了，需要做精简。因此需要将其转换成十六进制（hexadecimal，简称hex）。转换方式很简单，使用“8421法”将四位二进制数转换成十六进制数的一位，比如：1010（binary）会转为A（hex）。在 C 语言中，十六进制数以”0x”或“0X”开头，A表示10，F表示16。 </p>
<p>此后，00000000<del>11111111就可以用0x00</del>0xFF来表示了。</p>
<table>
<thead>
<tr>
<th>字符集</th>
<th align="left">字符编码</th>
<th align="left">简单介绍</th>
</tr>
</thead>
<tbody><tr>
<td>ASCII</td>
<td align="left">ASCII</td>
<td align="left">单字节，使用了7位</td>
</tr>
<tr>
<td>ISO-8859-1</td>
<td align="left">ISO-8859-1</td>
<td align="left">也叫Latin-1，单字节，扩展了ASCII，可解码ASCII</td>
</tr>
<tr>
<td>GB2312</td>
<td align="left">GB2312</td>
<td align="left">小于0XFF用单字节，否则用双字节</td>
</tr>
<tr>
<td>GBK</td>
<td align="left">GBK</td>
<td align="left">扩展GB2312，规则同上，可解码GB2312</td>
</tr>
<tr>
<td>Unicode</td>
<td align="left">UTF-8</td>
<td align="left">变长1-6字节</td>
</tr>
<tr>
<td>Unicode</td>
<td align="left">UTF-16</td>
<td align="left">双字节</td>
</tr>
<tr>
<td>Unicode</td>
<td align="left">UTF-32</td>
<td align="left">定长四字节</td>
</tr>
</tbody></table>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>float</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS宏(define)与常量(const)</title>
    <url>/2024/08/08/iOS/OC/003-OC%E6%96%B9%E6%B3%95/029-%E5%AE%8F(define)%E4%B8%8E%E5%B8%B8%E9%87%8F(const)/README/</url>
    <content><![CDATA[<h3 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h3><ul>
<li><a class="link"   href="https://www.jianshu.com/p/f83335e036b5" >iOS 宏(define)与常量(const)的正确使用 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link"   href="http://www.cocoachina.com/ios/20160519/16342.html" >15分钟弄懂 const 和 #define <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
<blockquote>
<p>注：配合我的文档<a class="link"   href="https://www.jianshu.com/p/2b0750a77284" >《static、const、extern简介与使用》 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>一起看更佳！！！</p>
</blockquote>
<hr>
<h1 id="Part-1-理解部分"><a href="#Part-1-理解部分" class="headerlink" title="Part 1 - 理解部分"></a>Part 1 - 理解部分</h1><hr>
<h2 id="一、什么是const"><a href="#一、什么是const" class="headerlink" title="一、什么是const ?"></a>一、什么是const ?</h2><blockquote>
<p>const是C&#x2F;C++中的一个关键字(修饰符), const一般用来定义一个常量, 既然叫做常量, 即以后再也不能修改其值.</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/08/08/iOS/OC/003-OC%E6%96%B9%E6%B3%95/029-%E5%AE%8F(define)%E4%B8%8E%E5%B8%B8%E9%87%8F(const)/README/003.png"
                      alt="const定义常量"
                ></p>
<h2 id="二、什么是-define"><a href="#二、什么是-define" class="headerlink" title="二、什么是#define?"></a>二、什么是#define?</h2><blockquote>
<p>define, 宏定义, 则是一条预编译指令, 编译器在编译阶段会将所有使用到宏的地方简单地进行替换. 如下图所示 :</p>
</blockquote>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/08/08/iOS/OC/003-OC%E6%96%B9%E6%B3%95/029-%E5%AE%8F(define)%E4%B8%8E%E5%B8%B8%E9%87%8F(const)/README/004.png"
                      alt="宏定义的替换"
                ></p>
<h2 id="三、他们有什么用"><a href="#三、他们有什么用" class="headerlink" title="三、他们有什么用?"></a>三、他们有什么用?</h2><ul>
<li><p>const 和 define 都能定义一个常量, 都能实现修改值修改一次, 则所有用上该常量的地方都同步改值, 一句代码都不用改.</p>
</li>
<li><p>使代码更易维护</p>
</li>
<li><p>提高代码的效率</p>
</li>
</ul>
<h2 id="四、他们有什么区别"><a href="#四、他们有什么区别" class="headerlink" title="四、他们有什么区别?"></a>四、他们有什么区别?</h2><ul>
<li><p>相同点</p>
<ul>
<li>都能定义常量</li>
</ul>
</li>
<li><p>不同点</p>
<ul>
<li><strong>const有修饰功能</strong> ：除了定义常量外，const 还有强大的修饰功能。#define 能增加程序的可读性，有些复杂的功能只需一条宏显示。</li>
<li><strong>类型检查</strong>：const 对数据进行类型检查。#define 无需进行类型检查。定义宏参数时需将参数（）起来。而且调用时参数不应在宏中再做运算。</li>
<li><strong>内存消耗</strong>：const定义常量从汇编的角度来看，只是给出了对应的内存地址，而不是象#define一样给出的是立即数，所以，const定义的常量在程序运行过程中只有一份拷贝，而#define定义的常量在内存中有若干个拷贝，所以宏在程序运行过程中所消耗的内存要比const变量的大得多。</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/08/08/iOS/OC/003-OC%E6%96%B9%E6%B3%95/029-%E5%AE%8F(define)%E4%B8%8E%E5%B8%B8%E9%87%8F(const)/README/005.png"
                      alt="分配内存"
                ></p>
<ul>
<li><p>编译器通常不为普通const常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，没有了存储与读内存的操作，使得它的效率比宏定义要高</p>
</li>
<li><p>宏能做到const不能办到的事.</p>
<ul>
<li>宏能定义函数</li>
<li>OC的单例模式用到宏</li>
<li>宏还能根据传入的参数生成字符串, 如下</li>
</ul>
</li>
</ul>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/08/08/iOS/OC/003-OC%E6%96%B9%E6%B3%95/029-%E5%AE%8F(define)%E4%B8%8E%E5%B8%B8%E9%87%8F(const)/README/006.png"
                      alt="image"
                ></p>
<hr>
<h1 id="Part-2-实战部分"><a href="#Part-2-实战部分" class="headerlink" title="Part 2 - 实战部分"></a>Part 2 - 实战部分</h1><hr>
<h2 id="五、define与const使用"><a href="#五、define与const使用" class="headerlink" title="五、define与const使用"></a>五、define与const使用</h2><p>你能区分下面的吗？知道什么时候用吗？</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define HSCoder @&quot;AAAAAA&quot;</span><br><span class="line">NSString *HSCoder = @&quot;AAAAAA&quot;;</span><br><span class="line">extern NSString *HSCoder;</span><br><span class="line">extern const NSString *HSCoder;</span><br><span class="line"></span><br><span class="line">static const NSString *HSCoder = @&quot;AAAAAA&quot;;</span><br><span class="line"></span><br><span class="line">const NSString *HSCoder = @&quot;AAAAAA&quot;;</span><br><span class="line">NSString const *HSCoder = @&quot;AAAAAA&quot;;</span><br><span class="line">NSString * const HSCoder = @&quot;AAAAAA&quot;;</span><br></pre></td></tr></table></figure></div>

<h3 id="宏："><a href="#宏：" class="headerlink" title="宏："></a>宏：</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define HSCoder @&quot;AAAAAA&quot;</span><br></pre></td></tr></table></figure></div>
<h3 id="变量："><a href="#变量：" class="headerlink" title="变量："></a>变量：</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSString *HSCoder = @&quot;AAAAAA&quot;;</span><br></pre></td></tr></table></figure></div>
<h3 id="常量："><a href="#常量：" class="headerlink" title="常量："></a>常量：</h3><p>四种写法：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">static const NSString *HSCoder = @&quot;AAAAAA&quot;;</span><br><span class="line">const NSString *HSCoder = @&quot;AAAAAA&quot;;</span><br><span class="line">NSString const *HSCoder = @&quot;AAAAAA&quot;;</span><br><span class="line">NSString * const HSCoder = @&quot;AAAAAA&quot;;</span><br></pre></td></tr></table></figure></div>


<h3 id="常量区分"><a href="#常量区分" class="headerlink" title="常量区分"></a>常量区分</h3><ul>
<li>全局常量：不管你定义在任何文件夹，外部都能访问<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">const NSString *HSCoder = @&quot;AAAAAA&quot;;</span><br></pre></td></tr></table></figure></div></li>
<li>局部常量：用static修饰后，不能提供外界访问<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">static const NSString *HSCoder = @&quot;AAAAAA&quot;;</span><br></pre></td></tr></table></figure></div></li>
</ul>
<h3 id="const修饰位置不同，代表什么？"><a href="#const修饰位置不同，代表什么？" class="headerlink" title="const修饰位置不同，代表什么？"></a>const修饰位置不同，代表什么？</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.const NSString *HSCoder = @&quot;AAAAAA&quot;;</span><br><span class="line">&quot;*HSCoder&quot;不能被修改， &quot;HSCoder&quot;能被修改</span><br><span class="line">2.NSString const *HSCoder = @&quot;AAAAAA&quot;;</span><br><span class="line">&quot;*HSCoder&quot;不能被修改， &quot;HSCoder&quot;能被修改</span><br><span class="line">3.NSString * const HSCoder = @&quot;AAAAAA&quot;;</span><br><span class="line">&quot;HSCoder&quot;不能被修改，&quot;*HSCoder&quot;能被修改</span><br></pre></td></tr></table></figure></div>

<p><strong>注意：1和2其实没什么区别</strong></p>
<p><strong>结论：const右边的总不能被修改</strong></p>
<p><strong>所以一般我们定义一个常量又不想被修改应该这样：</strong></p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSString * const HSCoder = @&quot;AAAAAA&quot;;</span><br></pre></td></tr></table></figure></div>

<h2 id="我的使用"><a href="#我的使用" class="headerlink" title="我的使用"></a>我的使用</h2><p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/08/08/iOS/OC/003-OC%E6%96%B9%E6%B3%95/029-%E5%AE%8F(define)%E4%B8%8E%E5%B8%B8%E9%87%8F(const)/README/001.png"
                      alt="h文件"
                ></p>
<p><img  
                     lazyload
                     src="/images/loading.svg"
                     data-src="/2024/08/08/iOS/OC/003-OC%E6%96%B9%E6%B3%95/029-%E5%AE%8F(define)%E4%B8%8E%E5%B8%B8%E9%87%8F(const)/README/002.png"
                      alt="m文件"
                ></p>
]]></content>
      <tags>
        <tag>const</tag>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>define</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS开发常用宏(define)</title>
    <url>/2024/08/08/iOS/OC/003-OC%E6%96%B9%E6%B3%95/029-%E5%AE%8F(define)%E4%B8%8E%E5%B8%B8%E9%87%8F(const)/iOS%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%AE%8F/</url>
    <content><![CDATA[<p><a class="link"   href="https://www.jianshu.com/p/213b3b96cafe" >iOS 日常工作之常用宏定义大全 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://www.jianshu.com/p/7e657365d2e6" >iOS-OC中常见的一些宏 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br><a class="link"   href="https://github.com/ibireme/YYCategories" >YYCategories <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><strong>1、长、宽、高</strong></li>
<li><strong>2、判断设备、系统版本</strong></li>
<li><strong>3、dispatch_main_async_safe</strong></li>
<li><strong>4、WeakSelf、StrongSelf</strong></li>
<li><strong>5、View 圆角、边框</strong></li>
<li><strong>6、获取沙盒路径</strong></li>
<li><strong>7、随机数</strong></li>
<li><strong>8、颜色设置相关</strong></li>
<li><strong>9、NSLog</strong></li>
</ul>
<p><strong>后续再更新…</strong></p>
<h3 id="1、长、宽、高"><a href="#1、长、宽、高" class="headerlink" title="1、长、宽、高"></a>1、长、宽、高</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// W H</span><br><span class="line">#define kSCREEN_SIZE [UIScreen mainScreen].bounds.size</span><br><span class="line">#define kSCREEN_WIDTH [UIScreen mainScreen].bounds.size.width</span><br><span class="line">#define kSCREEN_HEIGHT [UIScreen mainScreen].bounds.size.height</span><br><span class="line"></span><br><span class="line">#define kSTATUS_H    ([[UIApplication sharedApplication] statusBarFrame].size.height&gt;20?44:20) // 适配刘海屏状态栏</span><br><span class="line">#define kTABBAR_H    ([[UIApplication sharedApplication] statusBarFrame].size.height&gt;20?83:49) // 适配刘海屏底栏高度</span><br><span class="line">#define kBOTTOM_H    ([[UIApplication sharedApplication] statusBarFrame].size.height&gt;20?34:0)  // 适配刘海屏底部多出来的高度</span><br></pre></td></tr></table></figure></div>

<h3 id="2、判断设备、系统版本"><a href="#2、判断设备、系统版本" class="headerlink" title="2、判断设备、系统版本"></a>2、判断设备、系统版本</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">//----------------判断当前的iPhone设备/系统版本---------------</span><br><span class="line">// 判断是否为iPhone</span><br><span class="line">#define IS_IPHONE (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPhone)</span><br><span class="line">// 判断是否为iPad</span><br><span class="line">#define IS_IPAD (UI_USER_INTERFACE_IDIOM() == UIUserInterfaceIdiomPad)</span><br><span class="line">// 判断是否为ipod</span><br><span class="line">#define IS_IPOD ([[[UIDevice currentDevice] model] isEqualToString:@&quot;iPod touch&quot;])</span><br><span class="line"></span><br><span class="line">//----------------判断系统版本---------------</span><br><span class="line">// 获取系统版本</span><br><span class="line">#define IOS_SYSTEM_VERSION [[[UIDevice currentDevice] systemVersion] floatValue]</span><br><span class="line">// 判断 iOS 8 或更高的系统版本</span><br><span class="line">#define IOS_VERSION_8_OR_LATER (([[[UIDevice currentDevice] systemVersion] floatValue] &gt;=8.0)? (YES):(NO))</span><br><span class="line">// 判断 iOS 10 或更高的系统版本</span><br><span class="line">#define IOS_VERSION_10_OR_LATER (([[[UIDevice currentDevice] systemVersion] floatValue] &gt;=10.0)? (YES):(NO))</span><br><span class="line"></span><br><span class="line">//----------------判断机型 根据尺寸---------------</span><br><span class="line">// 判断是否为 iPhone 4/4S - 3.5 inch</span><br><span class="line">#define iPhone4_4S [[UIScreen mainScreen] bounds].size.width == 320.0f &amp;&amp; [[UIScreen mainScreen] bounds].size.height == 480.0f</span><br><span class="line">// 判断是否为 iPhone 5/5SE - 4.0 inch</span><br><span class="line">#define iPhone5_5SE [[UIScreen mainScreen] bounds].size.width == 320.0f &amp;&amp; [[UIScreen mainScreen] bounds].size.height == 568.0f</span><br><span class="line">// 判断是否为iPhone 6/6S/7/8 - 4.7 inch</span><br><span class="line">#define iPhone6_6S [[UIScreen mainScreen] bounds].size.width == 375.0f &amp;&amp; [[UIScreen mainScreen] bounds].size.height == 667.0f</span><br><span class="line">// 判断是否为iPhone 6Plus/6SPlus/7P/8P - 5.5 inch</span><br><span class="line">#define iPhone6Plus_8Plus [[UIScreen mainScreen] bounds].size.width == 414.0f &amp;&amp; [[UIScreen mainScreen] bounds].size.height == 736.0f</span><br><span class="line">// 判断是否为iPhoneX - 5.8 inch</span><br><span class="line">#define iPhoneX ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(1125, 2436), [[UIScreen mainScreen] currentMode].size) : NO)</span><br><span class="line">// 判断是否为iPhoneXS - 5.8 inch</span><br><span class="line">#define iPhoneXS ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(1125, 2436), [[UIScreen mainScreen] currentMode].size) : NO)</span><br><span class="line">// 判断是否为iPhoneXR - 6.1 inch</span><br><span class="line">#define iPhoneXR ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(828, 1792), [[UIScreen mainScreen] currentMode].size) : NO)</span><br><span class="line">// 判断是否为iPhoneXS MAX - 6.5 inch</span><br><span class="line">#define iPhoneXSMax ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(1242, 2688), [[UIScreen mainScreen] currentMode].size) : NO)</span><br><span class="line"></span><br><span class="line">// 主要是用于区分是否是 刘海屏</span><br><span class="line">#define LiuHaiPhone \</span><br><span class="line">(&#123;BOOL isLiuHaiPhone = NO;\</span><br><span class="line">if (@available(iOS 11.0, *)) &#123;\</span><br><span class="line">isLiuHaiPhone = [[UIApplication sharedApplication] delegate].window.safeAreaInsets.bottom &gt; 0.0;\</span><br><span class="line">&#125;\</span><br><span class="line">(isLiuHaiPhone);&#125;)</span><br></pre></td></tr></table></figure></div>






<h3 id="3、dispatch-main-async-safe"><a href="#3、dispatch-main-async-safe" class="headerlink" title="3、dispatch_main_async_safe"></a>3、dispatch_main_async_safe</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#ifndef dispatch_main_async_safe</span><br><span class="line">#define dispatch_main_async_safe(block)\</span><br><span class="line">if (strcmp(dispatch_queue_get_label(DISPATCH_CURRENT_QUEUE_LABEL), dispatch_queue_get_label(dispatch_get_main_queue())) == 0) &#123;\</span><br><span class="line">block();\</span><br><span class="line">&#125; else &#123;\</span><br><span class="line">dispatch_async(dispatch_get_main_queue(), block);\</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></div>

<p>How to use?</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">dispatch_main_async_safe(^&#123;</span><br><span class="line">    // UI in Main Thread</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
<p>详情</p>
<blockquote>
<p>参考与 <code>SDWebimage</code> 源码中，更详细的可参考 <a class="link"   href="https://www.jianshu.com/p/b8517dc833c7" >SDWebImage4.0源码探究（一）面试题
 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> 中 <strong>第七条 SDWebImage 如何保证UI操作放在主线程中执行？</strong></p>
</blockquote>
<h3 id="4、WeakSelf、StrongSelf"><a href="#4、WeakSelf、StrongSelf" class="headerlink" title="4、WeakSelf、StrongSelf"></a>4、WeakSelf、StrongSelf</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define WeakSelf(type)    __weak typeof(type) weak##type = type;</span><br><span class="line">#define StrongSelf(type)  __strong typeof(type) type = weak##type;</span><br></pre></td></tr></table></figure></div>

<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">__weak __typeof(self)weakSelf = self;</span><br><span class="line">AFNetworkReachabilityStatusBlock callback = ^(AFNetworkReachabilityStatus status) &#123;</span><br><span class="line">    __strong __typeof(weakSelf)strongSelf = weakSelf;</span><br><span class="line"></span><br><span class="line">    strongSelf.networkReachabilityStatus = status;</span><br><span class="line">    if (strongSelf.networkReachabilityStatusBlock) &#123;</span><br><span class="line">        strongSelf.networkReachabilityStatusBlock(status);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></div>


<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 使用一：</span><br><span class="line">    WeakSelf(self);</span><br><span class="line">    [btn mas_makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        StrongSelf(self);</span><br><span class="line">        make.left.equalTo(self.view);</span><br><span class="line">    &#125;];</span><br><span class="line">   </span><br><span class="line">// 使用二： </span><br><span class="line">    WeakSelf(self);</span><br><span class="line">    [btn mas_updateConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.right.equalTo(weakself.view);</span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure></div>


<h3 id="5、View-圆角、边框"><a href="#5、View-圆角、边框" class="headerlink" title="5、View 圆角、边框"></a>5、View 圆角、边框</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define LXViewBorderRadius(View, Radius, Width, UIColor)\</span><br><span class="line">\</span><br><span class="line">[View.layer setCornerRadius:(Radius)];\</span><br><span class="line">[View.layer setMasksToBounds:YES];\</span><br><span class="line">[View.layer setBorderWidth:(Width)];\</span><br><span class="line">[View.layer setBorderColor:[Color CGColor]]</span><br></pre></td></tr></table></figure></div>



<h3 id="6、获取沙盒路径"><a href="#6、获取沙盒路径" class="headerlink" title="6、获取沙盒路径"></a>6、获取沙盒路径</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">//--------------沙盒目录文件路径---------------</span><br><span class="line">// 获取沙盒主目录路径</span><br><span class="line">#define LXSBPath_Home = NSHomeDirectory();</span><br><span class="line">//获取沙盒 Document</span><br><span class="line">#define LXSBPath_Document [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]</span><br><span class="line">//获取沙盒 Library</span><br><span class="line">#define LXSBPath_Library [NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, NSUserDomainMask, YES) lastObject];</span><br><span class="line">//获取沙盒 Cache</span><br><span class="line">#define LXSBPath_Cache [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) firstObject]</span><br><span class="line">//获取temp</span><br><span class="line">#define LXSBPath_Temp NSTemporaryDirectory()</span><br></pre></td></tr></table></figure></div>

<h3 id="7、随机数"><a href="#7、随机数" class="headerlink" title="7、随机数"></a>7、随机数</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">//--------------生成随机数---------------</span><br><span class="line">#define LXRandNum(i) arc4random()%i   // [0,i) 范围内随机数</span><br><span class="line">#define LXRandNum_FromTo(i,j) (i + (arc4random() % (j – i + 1)))</span><br></pre></td></tr></table></figure></div>


<h3 id="8、颜色设置相关"><a href="#8、颜色设置相关" class="headerlink" title="8、颜色设置相关"></a>8、颜色设置相关</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">//---------------Colour-------------------</span><br><span class="line">// 设置随机颜色</span><br><span class="line">#define LXRandomColor [UIColor colorWithRed:arc4random_uniform(256)/255.0 green:arc4random_uniform(256)/255.0 blue:arc4random_uniform(256)/255.0 alpha:1.0]</span><br><span class="line">// 设置RGB颜色/设置RGBA颜色</span><br><span class="line">#define LXRGBAColor(r, g, b, a)  [UIColor colorWithRed:r/255.0f green:g/255.0f blue:b/255.0f alpha:a]</span><br><span class="line">#define LXRGBColor(r, g, b)      LXRGBAColor(r,g,b,1.0f)</span><br><span class="line">// 十六进制数值 eg:@&quot;#3499DB&quot;</span><br><span class="line">#define LXCOLOR_WITH_HEX [UIColor colorFromHexString: hexValue]</span><br><span class="line">#define LXCOLOR_WITH_HEX_1(hexValue) [UIColor colorWithRed:((float)((hexValue &amp; 0xFF0000) &gt;&gt; 16)) / 255.0 green:((float)((hexValue &amp; 0xFF00) &gt;&gt; 8)) / 255.0 blue:((float)(hexValue &amp; 0xFF)) / 255.0 alpha:1.0f]</span><br></pre></td></tr></table></figure></div>

<h3 id="9、NSLog"><a href="#9、NSLog" class="headerlink" title="9、NSLog"></a>9、NSLog</h3><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">//-------------- NSLog在release下不输出 ---------------</span><br><span class="line">#ifndef __OPTIMIZE__</span><br><span class="line">#define NSLog(...) NSLog(__VA_ARGS__)</span><br><span class="line">#else</span><br><span class="line"># define NSLog(...) &#123;&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></div>



]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>define</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS中Runloop应用场景</title>
    <url>/2024/08/09/iOS/OC/005-Runloop/01-Runloop%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/index/</url>
    <content><![CDATA[<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a class="link"   href="https://juejin.cn/post/6889769418541252615#heading-2" >Runloop-实际开发你想用的应用场景 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><ul>
<li>控制线程的生命周期【线程保活】</li>
<li>解决NSTimer在滑动过程中停止工作的问题及衍生问题</li>
<li>监控应用卡顿</li>
<li>性能优化</li>
</ul>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>Runloop</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS同步机制</title>
    <url>/2024/07/22/iOS/OC/006-%E5%A4%9A%E7%BA%BF%E7%A8%8B/002-iOS%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6/README/</url>
    <content><![CDATA[<!-- # iOS同步机制 -->

<p>iOS 提供了多种同步机制来确保多线程环境中的数据安全和操作一致性。以下是一些常用的同步机制：</p>
 <span id="more"></span>
<h3 id="1-synchronized"><a href="#1-synchronized" class="headerlink" title="1. @synchronized"></a>1. @synchronized</h3><p><code>synchronized</code> 是 Objective-C 中的一种便捷方式，用于确保代码块的执行是互斥的。它会创建一个隐式的锁对象，确保同一时间只有一个线程可以执行代码块内的代码。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@synchronized (self) &#123;</span><br><span class="line">    // 需要同步执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<p><strong>优点</strong>：简单易用，适合小范围的临界区保护。</p>
<p><strong>缺点</strong>：性能开销较大，不适合高频率调用。</p>
<h3 id="2-NSLock"><a href="#2-NSLock" class="headerlink" title="2. NSLock"></a>2. NSLock</h3><p><code>NSLock</code> 是一种基础的锁机制，提供了互斥锁的功能。使用时，需要显式地调用 <code>lock</code> 和 <code>unlock</code> 方法。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSLock *lock = [[NSLock alloc] init];</span><br><span class="line">[lock lock];</span><br><span class="line">// 需要同步执行的代码</span><br><span class="line">[lock unlock];</span><br></pre></td></tr></table></figure></div>

<p><strong>优点</strong>：相对于 <code>@synchronized</code>，性能稍好一些，使用灵活。</p>
<p><strong>缺点</strong>：需要显式调用锁和解锁，容易导致死锁。</p>
<h3 id="3-NSRecursiveLock"><a href="#3-NSRecursiveLock" class="headerlink" title="3. NSRecursiveLock"></a>3. NSRecursiveLock</h3><p><code>NSRecursiveLock</code> 是一种递归锁，允许同一线程多次获得锁而不会引发死锁。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSRecursiveLock *recursiveLock = [[NSRecursiveLock alloc] init];</span><br><span class="line">[recursiveLock lock];</span><br><span class="line">// 需要同步执行的代码</span><br><span class="line">[recursiveLock unlock];</span><br></pre></td></tr></table></figure></div>

<p><strong>优点</strong>：适合递归调用的场景。</p>
<p><strong>缺点</strong>：相对于普通锁，性能略低。</p>
<h3 id="4-NSCondition"><a href="#4-NSCondition" class="headerlink" title="4. NSCondition"></a>4. NSCondition</h3><p><code>NSCondition</code> 提供了一种更复杂的锁机制，支持线程等待和唤醒的功能。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSCondition *condition = [[NSCondition alloc] init];</span><br><span class="line">[condition lock];</span><br><span class="line">// 需要同步执行的代码</span><br><span class="line">[condition wait]; // 等待某个条件</span><br><span class="line">[condition signal]; // 唤醒等待的线程</span><br><span class="line">[condition unlock];</span><br></pre></td></tr></table></figure></div>

<p><strong>优点</strong>：适合需要线程等待和唤醒的复杂场景。</p>
<p><strong>缺点</strong>：使用复杂，性能较低。</p>
<h3 id="5-NSConditionLock"><a href="#5-NSConditionLock" class="headerlink" title="5. NSConditionLock"></a>5. NSConditionLock</h3><p><code>NSConditionLock</code> 是 <code>NSCondition</code> 的变种，增加了条件变量的支持，可以更方便地实现复杂的同步场景。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSConditionLock *conditionLock = [[NSConditionLock alloc] initWithCondition:0];</span><br><span class="line">[conditionLock lockWhenCondition:1];</span><br><span class="line">// 需要同步执行的代码</span><br><span class="line">[conditionLock unlockWithCondition:2];</span><br></pre></td></tr></table></figure></div>

<p><strong>优点</strong>：适合有条件变量的复杂场景。</p>
<p><strong>缺点</strong>：使用复杂，性能较低。</p>
<h3 id="6-GCD-Grand-Central-Dispatch"><a href="#6-GCD-Grand-Central-Dispatch" class="headerlink" title="6. GCD (Grand Central Dispatch)"></a>6. GCD (Grand Central Dispatch)</h3><p>GCD 提供了非常强大的多线程支持，特别是同步机制。常用的同步方法包括 <code>dispatch_sync</code> 和同步队列。</p>
<h4 id="串行队列"><a href="#串行队列" class="headerlink" title="串行队列"></a>串行队列</h4><p>创建一个串行队列，确保任务按顺序执行。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">dispatch_queue_t serialQueue = dispatch_queue_create(&quot;com.example.serialQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">dispatch_sync(serialQueue, ^&#123;</span><br><span class="line">    // 需要同步执行的代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<h4 id="dispatch-barrier"><a href="#dispatch-barrier" class="headerlink" title="dispatch_barrier"></a>dispatch_barrier</h4><p>在并行队列中使用 <code>dispatch_barrier_async</code> 或 <code>dispatch_barrier_sync</code> 确保读写操作的互斥性。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">dispatch_queue_t concurrentQueue = dispatch_queue_create(&quot;com.example.concurrentQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">dispatch_barrier_async(concurrentQueue, ^&#123;</span><br><span class="line">    // 需要同步执行的写操作</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>

<p><strong>优点</strong>：性能高，使用灵活，适合各种场景。</p>
<p><strong>缺点</strong>：API 较多，学习曲线稍高。</p>
<h3 id="7-Atomic-Properties"><a href="#7-Atomic-Properties" class="headerlink" title="7. Atomic Properties"></a>7. Atomic Properties</h3><p>在 Objective-C 中，可以使用 <code>atomic</code> 修饰符来声明线程安全的属性。尽管不适合所有情况，但在简单的读写操作中可以提供一定程度的线程安全保障。</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">@property (atomic, strong) NSString *atomicString;</span><br></pre></td></tr></table></figure></div>

<p><strong>优点</strong>：简单易用，适合简单的读写操作。</p>
<p><strong>缺点</strong>：性能较低，无法解决复杂的同步问题。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>iOS 提供了多种同步机制，从简单易用的 <code>@synchronized</code> 到强大灵活的 GCD，不同的机制适用于不同的场景。在选择同步机制时，需要根据具体需求和性能要求进行权衡。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>同步</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS 中的并发编程：GCD与Operation的对比与实践</title>
    <url>/2024/07/30/iOS/OC/006-%E5%A4%9A%E7%BA%BF%E7%A8%8B/018-GCD%E4%B8%8EOperation%E7%9A%84%E5%AF%B9%E6%AF%94%E4%B8%8E%E5%AE%9E%E8%B7%B5/README/</url>
    <content><![CDATA[<p>iOS平台上，有两种主流的并发编程技术：GCD（Grand Central Dispatch）和NSOperation。</p>
<span id="more"></span>

<h1 id="GCD"><a href="#GCD" class="headerlink" title="GCD"></a>GCD</h1><p>如何使用GCD创建一个并行队列并在其中执行一个耗时操作：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0);</span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">    // 执行耗时操作</span><br><span class="line">    for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">    // 更新UI</span><br><span class="line">    dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        // UI更新操作</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></div>
<p>在这个例子中，我们首先获取了一个全局的并行队列，然后在该队列中异步执行了一个循环操作。注意，当我们需要更新UI时，必须回到主线程进行操作。</p>
<h1 id="NSOperation"><a href="#NSOperation" class="headerlink" title="NSOperation"></a>NSOperation</h1><p>NSOperation是一个更为重量级的解决方案，它提供了更多的控制和灵活性。NSOperation对象可以被添加到NSOperationQueue中，后者负责管理这些操作的执行。与GCD不同，NSOperation允许设置依赖关系、取消操作以及观察操作的状态变化。</p>
<p>下面是一个使用NSOperation的简单示例：</p>
<div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tr><td class="code"><pre><span class="line">NSOperationQueue *queue = [[NSOperationQueue alloc] init];</span><br><span class="line">NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 100000; i++) &#123;</span><br><span class="line">        // ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br><span class="line">[queue addOperation:operation];</span><br></pre></td></tr></table></figure></div>
<p>在这个例子中，我们创建了一个NSOperationQueue实例，并添加了一个NSBlockOperation对象。NSBlockOperation类似于GCD中的block，但它提供了更丰富的特性，如能够取消操作或设置最大并发操作数。</p>
<h1 id="GPT"><a href="#GPT" class="headerlink" title="GPT"></a>GPT</h1><p>GCD（Grand Central Dispatch）和NSOperationQueue是iOS和macOS中用于并发编程的两个主要工具。它们都能帮助你管理和执行多线程任务，但在使用方式和特性上有一些关键区别。</p>
<h3 id="GCD（Grand-Central-Dispatch）"><a href="#GCD（Grand-Central-Dispatch）" class="headerlink" title="GCD（Grand Central Dispatch）"></a>GCD（Grand Central Dispatch）</h3><p><strong>特点：</strong></p>
<ol>
<li><strong>底层API</strong>：GCD是一个底层的C API，提供了强大的并发功能。</li>
<li><strong>简单直接</strong>：GCD使用dispatch queues来管理任务，通过block语法，使代码简洁易读。</li>
<li><strong>轻量级</strong>：GCD更轻量，性能开销更低，适合需要高效执行的大量小任务。</li>
<li><strong>自动管理线程</strong>：GCD会根据系统资源自动管理线程池，动态调整线程数量。</li>
<li><strong>适合简单并发任务</strong>：对于简单的任务提交和管理，GCD是一个很好的选择。</li>
</ol>
<p><strong>使用场景：</strong></p>
<ul>
<li>需要执行大量简单的并发任务，如网络请求、数据处理等。</li>
<li>需要轻量级的并发处理，不需要复杂的任务管理。</li>
<li>需要高性能和低开销。</li>
</ul>
<p><strong>示例代码：</strong></p>
<div class="highlight-container" data-rel="Swift"><figure class="iseeu highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">DispatchQueue</span>.global(qos: .background)</span><br><span class="line">queue.async &#123;</span><br><span class="line">    <span class="comment">// 在后台线程执行任务</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务执行&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div>

<h3 id="NSOperationQueue"><a href="#NSOperationQueue" class="headerlink" title="NSOperationQueue"></a>NSOperationQueue</h3><p><strong>特点：</strong></p>
<ol>
<li><strong>更高级的抽象</strong>：NSOperationQueue是基于面向对象的高级抽象，提供了更丰富的功能。</li>
<li><strong>依赖管理</strong>：可以设置任务之间的依赖关系，确保按顺序执行。</li>
<li><strong>任务取消</strong>：可以取消任务，适合需要精细控制的场景。</li>
<li><strong>任务状态管理</strong>：可以方便地追踪任务的执行状态（准备、执行、完成等）。</li>
<li><strong>键值观察</strong>：支持KVO（键值观察），可以观察任务的状态变化。</li>
</ol>
<p><strong>使用场景：</strong></p>
<ul>
<li>需要管理复杂的任务依赖关系。</li>
<li>需要取消任务或追踪任务状态。</li>
<li>需要在任务执行过程中进行KVO监控。</li>
</ul>
<p><strong>示例代码：</strong></p>
<div class="highlight-container" data-rel="Swift"><figure class="iseeu highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> queue <span class="operator">=</span> <span class="type">OperationQueue</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> operation1 <span class="operator">=</span> <span class="type">BlockOperation</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务1执行&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> operation2 <span class="operator">=</span> <span class="type">BlockOperation</span> &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;任务2执行&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置依赖关系，确保任务1在任务2之前执行</span></span><br><span class="line">operation2.addDependency(operation1)</span><br><span class="line"></span><br><span class="line">queue.addOperation(operation1)</span><br><span class="line">queue.addOperation(operation2)</span><br></pre></td></tr></table></figure></div>

<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li><strong>GCD</strong>：适合需要高性能、低开销、简单并发任务的场景。</li>
<li><strong>NSOperationQueue</strong>：适合需要复杂任务管理、依赖关系、任务取消和状态监控的场景。</li>
</ul>
<p>根据具体需求选择合适的工具，可以更好地优化应用的并发性能和任务管理。</p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>GCD</tag>
        <tag>Operation</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS中WKWebView秒开</title>
    <url>/2024/08/09/iOS/OC/009-%E6%B7%B7%E7%BC%96/001-WKWebView%E7%A7%92%E5%BC%80/index/</url>
    <content><![CDATA[<p><a class="link"   href="https://juejin.cn/post/6887161842406260744" >WKWebview秒开实践分享及问题解决方案 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <tags>
        <tag>iOS</tag>
        <tag>面试题</tag>
        <tag>WKWebView</tag>
      </tags>
  </entry>
</search>
